This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.cursor/
  mcp.json
.github/
  workflows/
    main.yml
resources/
  lib/
    ggml-metal.metal
  models/
    .gitignore
    download-ggml-model.sh
    README.md
  snapshots-default/
    snapshot-0e7a47de-710c-44d6-8ce5-504002496cde.json
    snapshot-15f8ce24-7c1c-4376-8cc1-31613736b85b.json
    snapshot-17b73b8e-168c-4c77-8df7-1a54b8fe3d9e.json
    snapshot-20f4d240-016c-40c6-8a7e-481059c660d8.json
    snapshot-298d5e79-347e-4ae5-a753-e62d8bc4ba2b.json
    snapshot-4109e1da-eaa9-4e20-ac44-22212299b9cb.json
    snapshot-475903d4-ccc4-4c03-9cd6-b34fd817b097.json
    snapshot-52cc1805-61a8-4492-affe-5e49adac622e.json
    snapshot-541429b7-4eb9-414f-a525-9a6c0b3903d4.json
    snapshot-58f2e99f-c21e-4a3c-a9f6-46daaa3bd7cd.json
    snapshot-5ff315a0-447e-48fc-8b5c-bc6c3401ec40.json
    snapshot-649c3d28-829b-4f65-a562-78f96eda9b62.json
    snapshot-ac3aa797-bfa7-432c-b47e-a0002c04202d.json
    snapshot-ae838d2f-3242-4e9f-88cc-174622cae92c.json
    snapshot-affa9d9a-87fc-4f6d-9577-ba87636dce91.json
    snapshot-b464964e-c8bc-4fe1-8438-a7f4dcedc50a.json
    snapshot-c514a0ed-594d-4c6a-993f-e054922731c4.json
    snapshot-c88ae8b5-db8b-4b3d-853b-46304af37b0c.json
    snapshot-ca595c06-6d1b-4977-8544-10bd71a5aaf1.json
    snapshot-cd3e0ecd-3d7c-497c-944e-1e611eaecf5a.json
    snapshot-ce4a8f46-a15b-4c73-9a75-7260ecbee0c5.json
    snapshot-d391cce1-2c54-4fa6-8f4e-2dc5b1619d22.json
    snapshot-e205e46a-02e5-4235-9fe0-e8c15580e309.json
    snapshot-e6067144-0a9c-4f2e-bf8f-18637448d5c8.json
    snapshot-e6ca6a23-bacf-4525-b1d0-bf01ce5c7bc7.json
    snapshot-f45bfad4-cc78-499c-bbcb-be030570c783.json
    snapshot-fd39f5ee-0ff9-4aee-becb-f24032857662.json
src/
  main/
    ipc/
      editor.ts
    menu/
      index.ts
    print/
      NotificationManager.ts
      PrintQueue.ts
      printStatusMessage.ts
      setPrintStatus.ts
    services/
      ipcHandlers.ts
      snapshots.ts
      WhisperStream.ts
    utils/
      applicationFolder.ts
      audioRecorder.ts
      helper.ts
      logger.ts
      simulateTranscriptForDevTesting.ts
      startPowerSaveBlocker.ts
    window/
      EditorWindow.ts
      MainWindow.ts
      PrintWindow.ts
    index.ts
  preload/
    index.d.ts
    index.ts
    print.ts
  renderer/
    src/
      assets/
        input-defaults/
          editorCss.ts
          editorSvgFilter.ts
          inlineStyle.ts
          input.json
          svgFilters.ts
        global.css
      components/
        codeEditor/
          css/
            commands/
              LivecodingKeymapExtra.ts
              PropertyEvaluator.ts
              StackModeEvaluator.ts
            Completions.ts
            ControllerValueSliderWidget.ts
            ControllerValuesLineAnnotation.ts
            FlashEffect.ts
            PropertyHighlighter.ts
          AIExtension.ts
          AIService.ts
          CodeEditor.svelte
          codemirror-ai.d.ts
        hooks/
          useDebounce.svelte.ts
        midi/
          ControllerManager.svelte
          MIDIKnobPreview.svelte
        pageElement/
          BlockImg.svelte
          BlockTxt.svelte
          checkPosition.ts
        status/
          PrintStatus.svelte
          PrintStatusBar.svelte
          TransInfoMessagesLog.svelte
        ui/
          PreviewButton.svelte
          SnapshotManager.svelte
      stores/
        commands.svelte.ts
        remoteSettings.svelte.ts
        settings.svelte.ts
        snapshots.svelte.ts
      utils/
        logger.ts
        math.ts
        styleMerger.ts
        utils.ts
      window/
        debug/
          components/
            LogContainer.svelte
            PageSimulator.svelte
            PageSimulatorWrapper.svelte
          App.svelte
          main.ts
        editor/
          App.svelte
          main.ts
        print/
          App.svelte
          main.ts
      App.svelte
      env.d.ts
      main.ts
      types.ts
    debug.html
    editor.html
    index.html
    print.html
  types/
    globals.d.ts
    index.ts
    ipc.d.ts
.gitignore
.prettierignore
.prettierrc.yaml
electron-builder.yml
electron.vite.config.ts
eslint.config.mjs
help-CodemirrorParserTreeStructure.md
LICENSE
package.json
pnpm-workspace.yaml
README.md
svelte.config.mjs
tsconfig.json
tsconfig.node.json
tsconfig.web.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/mcp.json">
{
  "mcpServers": {
    "memory": {
      "command": "npx",
      "args": ["-y", "@itseasy21/mcp-knowledge-graph"],
      "env": {
        "MEMORY_FILE_PATH": "/Users/milan/ai/cursor_memory/pub_transcriptions.jsonl"
      }
    }
  }
}
</file>

<file path=".github/workflows/main.yml">
name: Build/release

on:
  push:
    branches:
      - main
    tags:
      - 'v*'

jobs:
  build:
    runs-on: macos-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Download Whisper model
        run: pnpm dlwisper

      - name: Build app
        run: pnpm build

      - name: Build Electron app
        run: pnpm build:mac
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Zip app bundle
        run: |
          cd dist/mac-arm64
          zip -r "../Pub-Transcriptions-mac-arm64.zip" ./*

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: mac-arm64-build
          path: dist/Pub-Transcriptions-mac-arm64.zip
          if-no-files-found: error

      - name: Create Release
        if: startsWith(github.ref, 'refs/tags/v')
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create "$GITHUB_REF_NAME" \
            --repo="$GITHUB_REPOSITORY" \
            --title="Pub Transcriptions $GITHUB_REF_NAME" \
            --generate-notes \
            "./dist/Pub-Transcriptions-mac-arm64.zip#Mac arm64 App Bundle"
</file>

<file path="src/main/ipc/editor.ts">
import { dialog, ipcMain } from 'electron';
import { promises as fs } from 'fs';
import os from 'os';
import path from 'path';
import { editorWindowManager } from '../window/EditorWindow';

export function setupEditorIPC(): void {
  ipcMain.handle(
    'editor:openFile',
    async (_, { content, language }: { content: string; language: 'css' | 'html' }) => {
      const window = editorWindowManager.createEditorWindow({
        initialContent: content,
        language,
      });
      return window.id;
    },
  );

  // Handle save dialog
  ipcMain.handle('editor:save-dialog', async (event) => {
    const window = editorWindowManager.getEditorWindowFromWebContents(event.sender);
    if (!window) return null;

    const defaultPath = os.homedir();
    const result = await dialog.showSaveDialog(window, {
      defaultPath,
      filters: [
        { name: 'CSS Files', extensions: ['css'] },
        { name: 'HTML Files', extensions: ['html'] },
        { name: 'All Files', extensions: ['*'] },
      ],
    });

    if (result.canceled || !result.filePath) {
      return null;
    }

    return result.filePath;
  });

  // Handle setting represented file
  ipcMain.handle('editor:set-represented-file', (event, filePath) => {
    const window = editorWindowManager.getEditorWindowFromWebContents(event.sender);
    if (window) {
      window.setRepresentedFilename(filePath);
      window.setTitle(path.basename(filePath));
    }
  });

  // Handle setting document edited status
  ipcMain.handle('editor:set-document-edited', (event, edited) => {
    const window = editorWindowManager.getEditorWindowFromWebContents(event.sender);
    if (window) {
      window.setDocumentEdited(edited);
    }
  });

  // Handle save to file
  ipcMain.on('editor:save-to-file', async (event, { content, filePath }) => {
    try {
      if (!filePath) {
        return;
      }

      await fs.writeFile(filePath, content, 'utf8');

      // Set document as not edited
      const window = editorWindowManager.getEditorWindowFromWebContents(event.sender);
      if (window) {
        window.setDocumentEdited(false);
      }

      // Notify renderer that save is complete
      event.sender.send('editor:save-complete', filePath);
    } catch (error) {
      console.error('Error saving file:', error);
      event.sender.send('editor:save-complete', null);
    }
  });
}
</file>

<file path="src/main/menu/index.ts">
import { IpcEmitter } from '@electron-toolkit/typed-ipc/main';
import { BrowserWindow, Menu, MenuItemConstructorOptions, app, dialog, shell } from 'electron';
import { promises as fs } from 'fs';
import type { IpcRendererEvent } from '../../types/ipc';
import { editorWindowManager } from '../window/EditorWindow';
import { mainWindowManager } from '../window/MainWindow';

const emitter = new IpcEmitter<IpcRendererEvent>();

export function createMenu(): void {
  const isMac = process.platform === 'darwin';

  const template: MenuItemConstructorOptions[] = [
    // App menu (macOS only)
    ...(isMac
      ? [
          {
            label: app.name,
            submenu: [
              { role: 'about' as const },
              { type: 'separator' as const },
              { role: 'services' as const },
              { type: 'separator' as const },
              { role: 'hide' as const },
              { role: 'hideOthers' as const },
              { role: 'unhide' as const },
              { type: 'separator' as const },
              { role: 'quit' as const },
            ],
          },
        ]
      : []),

    // File menu
    {
      label: 'File',
      submenu: [
        {
          label: 'New Editor Window',
          accelerator: 'CmdOrCtrl+N',
          click: (): void => {
            editorWindowManager.createEditorWindow();
          },
        },
        {
          label: 'Open CSS File...',
          accelerator: 'CmdOrCtrl+O',
          click: async (): Promise<void> => {
            const result = await dialog.showOpenDialog({
              properties: ['openFile'],
              filters: [
                { name: 'CSS Files', extensions: ['css'] },
                { name: 'HTML Files', extensions: ['html'] },
                { name: 'All Files', extensions: ['*'] },
              ],
            });

            if (!result.canceled && result.filePaths.length > 0) {
              const filePath = result.filePaths[0];
              const content = await fs.readFile(filePath, 'utf8');
              const window = editorWindowManager.createEditorWindow({
                initialContent: content,
                language: 'css',
              });

              // Set the represented filename
              window.setRepresentedFilename(filePath);
              window.setTitle(filePath.split('/').pop() || filePath);

              // Send the file path to the renderer
              window.once('ready-to-show', () => {
                window.webContents.send('editor:opened-file', filePath);
              });
            }
          },
        },
        { type: 'separator' as const },
        {
          label: 'Save',
          accelerator: 'CmdOrCtrl+S',
          click: (): void => {
            const focusedWindow = BrowserWindow.getFocusedWindow();
            if (focusedWindow) {
              focusedWindow.webContents.send('editor:save');
            }
          },
        },
        {
          label: 'Save As...',
          accelerator: 'CmdOrCtrl+Shift+S',
          click: async (): Promise<void> => {
            const focusedWindow = BrowserWindow.getFocusedWindow();
            if (focusedWindow) {
              focusedWindow.webContents.send('editor:save-as');
            }
          },
        },
        { type: 'separator' as const },
        isMac ? { role: 'close' as const } : { role: 'quit' as const },
      ],
    },

    // Edit menu
    {
      label: 'Edit',
      submenu: [
        { role: 'undo' as const },
        { role: 'redo' as const },
        { type: 'separator' as const },
        { role: 'cut' as const },
        { role: 'copy' as const },
        { role: 'paste' as const },
        ...(isMac
          ? [
              { role: 'pasteAndMatchStyle' as const },
              { role: 'delete' as const },
              { role: 'selectAll' as const },
              { type: 'separator' as const },
              {
                label: 'Speech',
                submenu: [{ role: 'startSpeaking' as const }, { role: 'stopSpeaking' as const }],
              },
            ]
          : [
              { role: 'delete' as const },
              { type: 'separator' as const },
              { role: 'selectAll' as const },
            ]),
      ],
    },

    // Editor menu
    {
      label: 'Editor',
      submenu: [
        {
          label: 'Toggle Language',
          submenu: [
            {
              label: 'CSS',
              click: (): void => {
                const focusedWindow = BrowserWindow.getFocusedWindow();
                if (focusedWindow) {
                  editorWindowManager.setEditorLanguage(focusedWindow, 'css');
                }
              },
            },
            {
              label: 'HTML',
              click: (): void => {
                const focusedWindow = BrowserWindow.getFocusedWindow();
                if (focusedWindow) {
                  editorWindowManager.setEditorLanguage(focusedWindow, 'html');
                }
              },
            },
          ],
        },
      ],
    },

    // View menu
    {
      label: 'View',
      submenu: [
        { role: 'reload' as const },
        { role: 'forceReload' as const },
        { role: 'toggleDevTools' as const },
        { type: 'separator' as const },
        { role: 'resetZoom' as const },
        { role: 'zoomIn' as const },
        { role: 'zoomOut' as const },
        { type: 'separator' as const },
        { role: 'togglefullscreen' as const },
        { type: 'separator' as const },
        {
          label: 'Toggle Mini Mode',
          accelerator: 'CmdOrCtrl+M',
          click: (): void => {
            const mainWindow = mainWindowManager.getOrCreateMainWindow();
            // Get current mode based on window width
            const isCurrentlyMini = mainWindow.getBounds().width < 900;
            // Toggle to opposite mode
            const newMode = isCurrentlyMini ? 'full' : 'mini';

            const height = mainWindow.getBounds().height;
            if (newMode === 'mini') {
              const width = Math.round(height / 1.4142);
              mainWindow.setSize(width, height);
            } else {
              mainWindow.setSize(1200, height);
            }
            emitter.send(mainWindow.webContents, 'window:mode', newMode);
          },
        },
      ],
    },

    // Window menu
    {
      label: 'Window',
      submenu: [
        { role: 'minimize' as const },
        { role: 'zoom' as const },
        ...(isMac
          ? [
              { type: 'separator' as const },
              { role: 'front' as const },
              { type: 'separator' as const },
              { role: 'window' as const },
            ]
          : [{ role: 'close' as const }]),
      ],
    },

    // Help menu
    {
      role: 'help' as const,
      submenu: [
        {
          label: 'Learn More',
          click: async (): Promise<void> => {
            await shell.openExternal('https://github.com/yourusername/your-repo');
          },
        },
      ],
    },
  ];

  const menu = Menu.buildFromTemplate(template);
  Menu.setApplicationMenu(menu);
}
</file>

<file path="src/main/print/NotificationManager.ts">
import { Notification, shell } from 'electron';
import type { PrintCompletionEvent } from '../../types/index';
import { printLogger } from '../utils/logger';

/**
 * NotificationManager handles desktop notifications for print jobs
 * Features:
 * - Create, update, and dismiss notifications
 * - Add actions to notifications (like opening PDFs)
 * - Ensures visibility of updated notifications
 * - Tracks active notifications
 * - Auto-dismisses notifications based on print job events
 */
export class NotificationManager {
  private activeNotifications = new Map<string, Notification>();

  constructor() {
    // Check if notifications are supported on startup
    if (!Notification.isSupported()) {
      printLogger.warn('Notifications are not supported on this system');
    }
  }

  /**
   * Shows a notification for a print job
   * @param printId - The ID of the print job
   * @param title - The title of the notification
   * @param options - Additional notification options
   */
  showNotification(
    printId: string,
    title: string,
    options?: {
      body?: string;
      silent?: boolean;
      path?: string;
    },
  ): void {
    // If notifications aren't supported, do nothing
    if (!Notification.isSupported()) {
      return;
    }

    // Dismiss existing notification if present
    if (this.activeNotifications.has(printId)) {
      const existingNotification = this.activeNotifications.get(printId);
      if (existingNotification) {
        existingNotification.close();
        this.activeNotifications.delete(printId);

        // Wait a bit before showing the updated notification to ensure it appears as new
        setTimeout(() => {
          this.createAndShowNotification(printId, title, options);
        }, 300);
        return;
      }
    }

    // Create and show notification
    this.createAndShowNotification(printId, title, options);
  }

  /**
   * Dismisses a notification for a print job
   * @param printId - The ID of the print job
   */
  dismissNotification(printId: string): void {
    if (this.activeNotifications.has(printId)) {
      const notification = this.activeNotifications.get(printId);
      if (notification) {
        notification.close();
        this.activeNotifications.delete(printId);
      }
    }
  }

  /**
   * Handles a print completion event and updates or dismisses notifications accordingly
   * @param event - The print completion event
   * @param autoDismissDelayMs - Delay before auto-dismissing successful notifications (default: 5000ms)
   */
  handlePrintCompletion(event: PrintCompletionEvent, autoDismissDelayMs = 5000): void {
    if (this.hasNotification(event.printId)) {
      if (!event.success && event.error) {
        // Don't dismiss on error - notification already updated in PrintWindow:ReadyToBePrinted handler
        // or should be updated by the caller
      } else {
        // For successful jobs, the notification will be dismissed after a delay
        // to give the user time to see the success message
        setTimeout(() => {
          this.dismissNotification(event.printId);
        }, autoDismissDelayMs);
      }
    }
  }

  /**
   * Creates and shows a notification with the specified options
   * @param printId - The ID of the print job
   * @param title - The title of the notification
   * @param options - Notification options
   */
  private createAndShowNotification(
    printId: string,
    title: string,
    options?: {
      body?: string;
      silent?: boolean;
      path?: string;
    },
  ): void {
    // Prepare notification options
    const notificationOptions: Electron.NotificationConstructorOptions = {
      title: title,
      body: options?.body || `Print job ${printId} is in progress`,
      silent: options?.silent !== undefined ? options.silent : false,
    };

    // Add actions for PDF notifications
    if (options?.path) {
      notificationOptions.actions = [
        {
          type: 'button',
          text: 'Open PDF',
        },
      ];
    }

    const notification = new Notification(notificationOptions);

    // Add click handler for PDF actions
    if (options?.path) {
      notification.on('action', (_event, index) => {
        if (index === 0) {
          // First action (Open PDF)
          this.openFile(options.path!);
        }
      });

      // Also open PDF on regular click
      notification.on('click', () => {
        this.openFile(options.path!);
      });
    }

    // Store the notification reference
    this.activeNotifications.set(printId, notification);

    // Show the notification
    notification.show();
  }

  /**
   * Checks if there's an active notification for the specified print job
   * @param printId - The ID of the print job
   * @returns Whether there's an active notification
   */
  hasNotification(printId: string): boolean {
    return this.activeNotifications.has(printId);
  }

  /**
   * Dismisses all active notifications
   */
  dismissAll(): void {
    this.activeNotifications.forEach((notification, printId) => {
      notification.close();
      this.activeNotifications.delete(printId);
    });
  }

  /**
   * Opens a file using the default application
   * @param filePath - The path to the file to open
   */
  openFile(filePath: string): void {
    if (filePath) {
      shell
        .openPath(filePath)
        .then((result) => {
          if (result !== '') {
            printLogger.error(`Error opening file: ${result}`);
          }
        })
        .catch((err) => {
          printLogger.error('Error opening file:', err);
        });
    }
  }
}

// Export a singleton instance
export const notificationManager = new NotificationManager();
</file>

<file path="src/main/print/PrintQueue.ts">
import { app } from 'electron';
import { EventEmitter } from 'events';
import type { PrintJob, QueueStatus } from '../../types/index.ts';
import { printLogger } from '../utils/logger.ts';
import { printWindowManager } from '../window/PrintWindow.js';
import { notificationManager } from './NotificationManager.js';
// The NotificationManager is used directly here to handle print job notifications
// This allows for centralized notification management without relying on external handlers

interface PrintQueueJob extends PrintJob {
  resolve: (value: unknown) => void;
  reject: (error: Error) => void;
  retries: number;
  addedAt: number;
}

interface PrintJobResult {
  success: boolean;
  error?: string;
  retrying?: boolean;
}

interface ExtendedQueueStatus extends QueueStatus {
  currentJob: {
    addedAt: number;
    retries: number;
    job: PrintQueueJob;
  } | null;
}

interface PrintQueueResult {
  queued: boolean;
  completion: Promise<unknown>;
}

/**
 * PrintQueue manages a queue of print jobs for electron windows.
 * Handles print job processing, retries, timeouts and window management.
 *
 * Features:
 * - Configurable retry attempts for failed jobs
 * - Timeout handling for stalled jobs
 * - Auto-recreation of print windows if destroyed
 * - Queue status updates via IPC
 * - Graceful cleanup of pending jobs
 */
export class PrintQueue {
  private queue: PrintQueueJob[] = [];
  private isProcessing = false;
  private readonly maxRetries = 3;
  private readonly timeout = 1 * 60 * 1000; // 1 minute timeout
  private printEvents: EventEmitter;

  constructor(eventEmitter?: EventEmitter) {
    this.printEvents = eventEmitter || new EventEmitter();
    this.updateQueueStatus();
  }

  // This function allows setting or replacing the event emitter after creation
  setPrintEvents(eventEmitter: EventEmitter): void {
    this.printEvents = eventEmitter;
  }

  getPrintEvents(): EventEmitter {
    return this.printEvents;
  }

  async add(printJob: PrintJob): Promise<PrintQueueResult> {
    const jobPromise = new Promise((resolve, reject) => {
      const job: PrintQueueJob = {
        ...printJob,
        resolve,
        reject,
        retries: 0,
        addedAt: Date.now(),
      };

      this.queue.push(job);
      printLogger.info(`Added job to queue. Queue length: ${this.queue.length}`);
      this.updateQueueStatus();
      this.processNext();
    });

    // Return both the immediate success and the job completion promise
    return {
      queued: true,
      completion: jobPromise,
    };
  }

  private updateQueueStatus(): void {
    const status = this.getQueueStatus();
    // Update the app badge count to reflect queue length
    app.badgeCount = status.queueLength;
  }

  private async processNext(): Promise<void> {
    if (this.isProcessing || this.queue.length === 0) return;

    this.isProcessing = true;
    this.updateQueueStatus();
    const job = this.queue[0];

    try {
      // Process the job using the printWindow
      const result = await new Promise<PrintJobResult>((resolve, reject) => {
        const timeoutId = setTimeout(() => {
          cleanup();

          // If we haven't exceeded max retries, move job to end of queue
          if (job.retries < this.maxRetries) {
            job.retries++;
            this.queue.push({
              ...job,
              addedAt: Date.now(), // Reset the timestamp
            });
            printLogger.warn(
              `Job timed out, retrying later. Attempt ${job.retries}/${this.maxRetries}`,
            );
            resolve({ success: false, retrying: true });
          } else {
            printLogger.error(`Job failed after ${this.maxRetries} attempts`);
            reject(new Error(`Print job failed after ${this.maxRetries} attempts`));
          }
        }, this.timeout);

        const cleanup = (): void => {
          this.printEvents.removeListener('INTERNAL-PrintQueueEvent:complete', handleComplete);
          clearTimeout(timeoutId);
        };

        const handleComplete = ({
          printId,
          success,
          error,
        }: {
          printId: string;
          success: boolean;
          error?: string;
        }): void => {
          if (printId !== job.printId) return;

          // Handle notification directly
          const completionEvent = { printId, success, error };
          notificationManager.handlePrintCompletion(completionEvent);

          cleanup();
          if (success) {
            resolve({ success: true });
          } else {
            resolve({ success: false, error });
          }
        };

        this.printEvents.on('INTERNAL-PrintQueueEvent:complete', handleComplete);

        // Send the job to the print window via the printWindow
        try {
          printLogger.info(`Sending job ${job.printId} to print window`);

          printWindowManager
            .sendJobToPrintWindow({
              ...job,
              attempt: job.retries,
              maxRetries: this.maxRetries,
            })
            .catch((err) => {
              cleanup();
              reject(err);
            });
        } catch (error) {
          cleanup();
          reject(
            new Error(
              `Failed to send job to print window: ${error instanceof Error ? error.message : String(error)}`,
            ),
          );
        }
      });

      if (result.success) {
        printLogger.info(`Job ${job.printId} completed successfully`);
        job.resolve(result);
      } else if (!result.retrying) {
        printLogger.warn(`Job ${job.printId} failed: ${result.error}`);
        job.reject(new Error(result.error || 'Print failed'));
      }
    } catch (error) {
      printLogger.error('Print job error:', error);
      job.reject(error instanceof Error ? error : new Error(String(error)));
    } finally {
      // Always clean up the current job
      this.queue.shift();
      this.isProcessing = false;
      this.updateQueueStatus();

      // Process next job after a delay to allow for SVG filters and window stabilization
      if (this.queue.length > 0) {
        printLogger.info(`Will process next job in 1s. Queue length: ${this.queue.length}`);
        setTimeout(() => {
          printLogger.info('Processing next job after delay');
          this.processNext();
        }, 1000);
      } else {
        printLogger.info('Queue is empty');
      }
    }
  }

  getQueueStatus(): ExtendedQueueStatus {
    return {
      queueLength: this.queue.length,
      isProcessing: this.isProcessing,
      currentJob: this.queue[0]
        ? {
            addedAt: this.queue[0].addedAt,
            retries: this.queue[0].retries,
            job: this.queue[0],
          }
        : null,
    };
  }

  cleanup(): void {
    if (this.queue.length > 0) {
      printLogger.info(`Cleaning up ${this.queue.length} remaining print jobs`);

      // Emit completion events for all remaining jobs to clean up notifications
      this.queue.forEach((job) => {
        const completionEvent = {
          printId: job.printId,
          success: false,
          error: 'Print queue was cleared',
        };
        // Directly handle notification dismissal
        notificationManager.handlePrintCompletion(completionEvent, 0); // Immediate dismissal
      });
    }
    this.queue = [];
    this.isProcessing = false;
    // Reset badge count when cleaning up the queue
    app.badgeCount = 0;
  }

  /**
   * Check if there are any active jobs in the queue
   * @returns true if there are jobs in the queue or a job is being processed
   */
  hasActiveJobs(): boolean {
    return this.queue.length > 0 || this.isProcessing;
  }
}

export const printQueue = new PrintQueue();
</file>

<file path="src/main/print/printStatusMessage.ts">
import type { PrintAction, PrintStatus, PrintStatusMessage } from '../../types';

/**
 * Print status action types
 * @readonly
 */
export const PRINT_ACTIONS = {
  PRINT_START: 'PRINT_START',
  PRINT_COMPLETE: 'PRINT_COMPLETE',
  PDF_SAVE: 'PDF_SAVE',
  PRINT_ERROR: 'PRINT_ERROR',
} as const;

/**
 * Print status types
 * @readonly
 */
export const PRINT_STATUS = {
  SUCCESS: 'SUCCESS',
  ERROR: 'ERROR',
  INFO: 'INFO',
} as const;

interface PrintStatusDetails {
  message?: string;
  error?: string;
  path?: string;
  details?: Record<string, unknown>;
}

/**
 * Creates a standardized print status message
 * @param printId - The ID of the print job
 * @param action - The action being performed
 * @param status - The status of the action
 * @param details - Additional details about the print status
 * @returns Formatted status message
 */
export function createPrintStatusMessage(
  printId: string,
  action: PrintAction,
  status: PrintStatus,
  details: PrintStatusDetails = {},
): PrintStatusMessage {
  return {
    id: printId,
    timestamp: Date.now(),
    action,
    status,
    ...details,
  };
}
</file>

<file path="src/main/print/setPrintStatus.ts">
import { IpcEmitter } from '@electron-toolkit/typed-ipc/main';
import { app, BrowserWindow } from 'electron';
import type { PrintStatusMessage } from '../../types';
import type { IpcRendererEvent } from '../../types/ipc';
import { printLogger } from '../utils/logger';
import { notificationManager } from './NotificationManager';
import { createPrintStatusMessage, PRINT_ACTIONS, PRINT_STATUS } from './printStatusMessage';

class NotifyStatus {
  private emitter: IpcEmitter<IpcRendererEvent>;

  constructor() {
    this.emitter = new IpcEmitter<IpcRendererEvent>();
  }

  /**
   * Send a status message to all open windows
   */
  private sendToAllWindows(status: PrintStatusMessage): void {
    const allWindows = BrowserWindow.getAllWindows();
    const windows = [...allWindows].filter(Boolean);
    printLogger.info('Sending to windows', 'print-status', status.message);
    windows.forEach((window) => {
      if (window && !window.isDestroyed()) {
        this.emitter.send(window.webContents, 'print-status', status);
      } else {
        printLogger.warn('Window is not available', window);
      }
    });
  }

  /**
   * Notify that print has started
   */
  printStart(printId: string, message?: string): void {
    const status = createPrintStatusMessage(printId, PRINT_ACTIONS.PRINT_START, PRINT_STATUS.INFO, {
      message: message || '(っ◔◡◔)っ ♥🎀 we are trying to print 🎀♥',
    });
    this.sendToAllWindows(status);
  }

  /**
   * Notify that print has completed successfully
   */
  printSuccess(printId: string, message?: string): void {
    const status = createPrintStatusMessage(
      printId,
      PRINT_ACTIONS.PRINT_COMPLETE,
      PRINT_STATUS.SUCCESS,
      { message: message || '🖨️ Print completed' },
    );
    this.sendToAllWindows(status);

    // Update notification for print completion
    notificationManager.showNotification(printId, 'Print Completed', {
      body: '🖨️ Print job completed successfully',
      silent: true,
    });
  }

  /**
   * Notify that print has failed
   */
  printError(printId: string, error: unknown): void {
    const errorMessage = error instanceof Error ? error.message : String(error);
    const status = createPrintStatusMessage(
      printId,
      PRINT_ACTIONS.PRINT_ERROR,
      PRINT_STATUS.ERROR,
      {
        message: `🥵 Error: ${errorMessage}`,
        error: errorMessage,
      },
    );
    this.sendToAllWindows(status);

    // Update notification for print failure
    notificationManager.showNotification(printId, 'Print Failed', {
      body: `Printing failed: ${errorMessage}`,
      silent: false,
    });
  }

  /**
   * Notify that PDF has been saved successfully
   */
  pdfSuccess(printId: string, pdfPath: string): void {
    const status = createPrintStatusMessage(printId, PRINT_ACTIONS.PDF_SAVE, PRINT_STATUS.SUCCESS, {
      message: `💦 Wrote PDF successfully to ${pdfPath}`,
      path: pdfPath,
    });
    this.sendToAllWindows(status);
    app.dock?.bounce();
  }
}

export const notifyStatus = new NotifyStatus();
</file>

<file path="src/main/services/ipcHandlers.ts">
import { IpcEmitter, IpcListener } from '@electron-toolkit/typed-ipc/main';
import { app, BrowserWindow } from 'electron';
import Store from 'electron-store';
import { EventEmitter } from 'events';
import { existsSync, promises as fs } from 'fs';
import { join } from 'path';

import type { PrintCompletionEvent, SettingsSnapshot } from '../../types';
import { printJobSchema } from '../../types/index';
import type { IpcEvents, IpcRendererEvent } from '../../types/ipc';
import { notificationManager } from '../print/NotificationManager';
import { printQueue } from '../print/PrintQueue';
import { notifyStatus } from '../print/setPrintStatus';
import { openPdfFolder } from '../utils/helper';
import { ipcLogger } from '../utils/logger';
import { printWindowManager } from '../window/PrintWindow';
import { deleteSnapshot, getSnapshots, loadSnapshot, saveSnapshot } from './snapshots';

const store = new Store();
const ipc = new IpcListener<IpcEvents>();
const emitter = new IpcEmitter<IpcRendererEvent>();
export const printEvents = new EventEmitter();

// Share the EventEmitter with the print queue
printQueue.setPrintEvents(printEvents);

// Default print options
const DEFAULT_PRINT_OPTIONS = {
  margins: {
    marginType: 'custom' as const,
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
  },
  pageSize: 'A3' as const,
  printBackground: true,
  landscape: false,
  silent: true,
  scaleFactor: 100,
  generateTaggedPDF: true,
  generateDocumentOutline: true,
};

export function setupIpcHandlers(): void {
  // Print request handler
  ipc.on('print', async (event, requestUnsave) => {
    try {
      const printJob = printJobSchema.parse(requestUnsave);

      ipcLogger.info('📝 Print request received:', printJob.printId);

      // Create notification for queued print job
      notificationManager.showNotification(printJob.printId, 'Print Job Queued', {
        body: `Your print job has been added to the queue.`,
        silent: true,
      });

      await printQueue.add(printJob);

      // Send queue notification immediately
      emitter.send(event.sender, 'print-queued', {
        success: true,
        printId: printJob.printId,
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const printId = requestUnsave?.printId ?? '000';
      ipcLogger.error('Print queue error:', errorMessage);

      notificationManager.showNotification(printId, 'Print Error', {
        body: `Error: ${errorMessage}`,
        silent: false,
      });

      emitter.send(event.sender, 'print-queued', {
        success: false,
        error: errorMessage,
        printId,
      });
    }
  });

  // Store value handlers
  ipc.handle('getStoreValue', (_event, key) => {
    return store.get(key);
  });

  ipc.handle('setStoreValue', (_event, key, value) => {
    return store.set(key, value);
  });

  // Settings snapshot handlers
  ipc.handle('save-settings-snapshot', async (_event, snapshot: SettingsSnapshot) => {
    return await saveSnapshot(snapshot);
  });

  ipc.handle('get-settings-snapshots', async () => {
    return await getSnapshots();
  });

  ipc.handle('load-settings-snapshot', async (_event, id: string) => {
    return await loadSnapshot(id);
  });

  ipc.handle('delete-settings-snapshot', async (_event, id: string) => {
    return await deleteSnapshot(id);
  });

  // Handle settings sync between windows
  ipc.on('editor:settings-updated', (_event, settings) => {
    ipcLogger.info('Settings updated from editor, syncing to other windows');
    // Broadcast to all windows
    BrowserWindow.getAllWindows().forEach((window) => {
      emitter.send(window.webContents, 'settings-sync', settings);
      if (window.webContents.isDestroyed()) return;
      try {
        emitter.send(window.webContents, 'settings-sync', settings);
      } catch (err) {
        ipcLogger.error('Error sending settings sync to window:', err);
      }
    });
  });

  // Handle settings sync between windows
  ipc.on('editor:stackmode', (_event, mode) => {
    ipcLogger.info('Stackmode updated from editor, syncing to other windows');
    // Broadcast to all windows
    BrowserWindow.getAllWindows().forEach((window) => {
      if (window.webContents.isDestroyed()) return;
      try {
        emitter.send(window.webContents, 'editor:stackmode', mode);
      } catch (err) {
        ipcLogger.error('Error sending stackmode sync to window:', err);
      }
    });
  });

  // Handle editor commands
  ipc.on('editor:command', (_event, command, payload) => {
    ipcLogger.info('Editor command received:', command);
    // Broadcast to all windows
    BrowserWindow.getAllWindows().forEach((window) => {
      if (window.webContents.isDestroyed()) return;
      try {
        // Forward the command to all windows
        emitter.send(window.webContents, 'editor:command', command, payload);
      } catch (err) {
        ipcLogger.error('Error sending editor command to window:', err);
      }
    });
  });

  // PDF folder handler
  ipc.handle('open-pdf-folder', async () => {
    return openPdfFolder();
  });

  // Print execution handler
  ipc.handle('PrintWindow:ReadyToBePrinted', async (_event, request) => {
    try {
      const printJob = printJobSchema.parse(request);
      // Get the print window from the manager
      const printWindow = printWindowManager.getOrCreatePrintWindow();

      ipcLogger.info('📝 Execute print request:', {
        contentLength: printJob.pageContent.html.length,
        printId: printJob.printId,
      });

      const printOptions = {
        ...DEFAULT_PRINT_OPTIONS,
        silent: printJob.do.print.silent ?? DEFAULT_PRINT_OPTIONS.silent,
      };

      const pdfOptions = {
        margins: printOptions.margins,
        pageSize: printOptions.pageSize,
        landscape: printOptions.landscape,
        printBackground: printOptions.printBackground,
      };

      notifyStatus.printStart(printJob.printId);

      // Handle direct printing
      if (printJob.do.print.yes === true) {
        await new Promise<void>((resolve, reject) => {
          ipcLogger.info('Printing...', printOptions);
          printWindow.webContents.print(printOptions, (success, errorType) => {
            if (!success) {
              ipcLogger.error('Printing failed', errorType);
              notifyStatus.printError(printJob.printId, errorType);
              reject(new Error(errorType));
            } else {
              ipcLogger.info('Printing completed');
              notifyStatus.printSuccess(printJob.printId);
              resolve();
            }
          });
        });
      }

      // Default to handle PDF saving
      if (printJob.do.pdfSave?.yes !== false) {
        const dateString = new Date().toISOString().replace(/:/g, '-');
        const pdfDir = join(app.getPath('userData'), 'pdfs');

        if (!existsSync(pdfDir)) {
          await fs.mkdir(pdfDir, { recursive: true });
        }

        const pdfPath = join(pdfDir, `transcript-${dateString}.pdf`);
        ipcLogger.debug('Printing to PDF...', pdfPath, pdfOptions);
        const pdfData = await printWindow.webContents.printToPDF(pdfOptions);

        if (pdfData) {
          await fs.writeFile(pdfPath, pdfData);
          ipcLogger.info(`Wrote PDF successfully to ${pdfPath}`);

          notifyStatus.pdfSuccess(printJob.printId, pdfPath);

          const notificationTitle = printJob.do.print.yes
            ? 'Print Job & PDF Completed'
            : 'PDF Generated Successfully';

          const notificationBody = printJob.do.print.yes
            ? `Print completed and PDF saved. Click to open.`
            : `PDF saved successfully. Click to open.`;

          notificationManager.showNotification(printJob.printId, notificationTitle, {
            body: notificationBody,
            silent: true,
            path: pdfPath,
          });
        }
      }

      // Emit completion event regardless
      printEvents.emit('INTERNAL-PrintQueueEvent:complete', {
        printId: printJob.printId,
        success: true,
      } as PrintCompletionEvent);

      return true;
    } catch (error) {
      ipcLogger.error('Print/PDF error:', error);
      const printId = request?.printId || '000';

      notifyStatus.printError(printId, error);

      // Emit error event for PrintQueue
      const completionEvent: PrintCompletionEvent = {
        printId,
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
      printEvents.emit('INTERNAL-PrintQueueEvent:complete', completionEvent);

      throw error;
    }
  });
}
</file>

<file path="src/main/services/snapshots.ts">
import { app } from 'electron';
import { existsSync, promises as fs } from 'fs';
import { join } from 'path';
import { v4 as uuidv4 } from 'uuid';
import type { SettingsSnapshot, SettingsSnapshotListResponse } from '../../types';

// Snapshots directory
const SNAPSHOTS_DIR = join(app.getPath('userData'), 'setting-snapshots');

// Ensure snapshots directory exists
async function ensureSnapshotsDir(): Promise<void> {
  if (!existsSync(SNAPSHOTS_DIR)) {
    await fs.mkdir(SNAPSHOTS_DIR, { recursive: true });
  }
}

// Save a settings snapshot
export async function saveSnapshot(snapshot: SettingsSnapshot): Promise<SettingsSnapshot> {
  try {
    await ensureSnapshotsDir();

    // Generate ID if not provided
    if (!snapshot.id) {
      snapshot.id = uuidv4();
    }

    // Add timestamp if not provided
    if (!snapshot.timestamp) {
      snapshot.timestamp = Date.now();
    }

    // Create filename with ID for uniqueness
    const filename = `snapshot-${snapshot.id}.json`;
    const filePath = join(SNAPSHOTS_DIR, filename);

    // Write snapshot to file
    await fs.writeFile(filePath, JSON.stringify(snapshot, null, 2), 'utf-8');

    return snapshot;
  } catch (error) {
    console.error('Error saving settings snapshot:', error);
    throw error;
  }
}

// Get all settings snapshots
export async function getSnapshots(): Promise<SettingsSnapshotListResponse> {
  try {
    await ensureSnapshotsDir();

    // Get all snapshot files
    const files = await fs.readdir(SNAPSHOTS_DIR);
    const snapshotFiles = files.filter(
      (file) => file.startsWith('snapshot-') && file.endsWith('.json'),
    );

    // Load each snapshot file
    const snapshots: SettingsSnapshot[] = [];

    for (const file of snapshotFiles) {
      try {
        const content = await fs.readFile(join(SNAPSHOTS_DIR, file), 'utf-8');
        const snapshot = JSON.parse(content) as SettingsSnapshot;
        snapshots.push(snapshot);
      } catch (e) {
        console.error(`Error reading snapshot file ${file}:`, e);
        // Continue with other files
      }
    }

    // Sort by timestamp (newest first)
    snapshots.sort((a, b) => b.timestamp - a.timestamp);

    return {
      snapshots,
      success: true,
    };
  } catch (error) {
    console.error('Error getting settings snapshots:', error);
    return {
      snapshots: [],
      success: false,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}

// Load a specific settings snapshot
export async function loadSnapshot(id: string): Promise<SettingsSnapshot | null> {
  try {
    await ensureSnapshotsDir();

    const filename = `snapshot-${id}.json`;
    const filePath = join(SNAPSHOTS_DIR, filename);

    if (!existsSync(filePath)) {
      console.warn(`Snapshot with ID ${id} not found`);
      return null;
    }

    const content = await fs.readFile(filePath, 'utf-8');
    return JSON.parse(content) as SettingsSnapshot;
  } catch (error) {
    console.error(`Error loading snapshot with ID ${id}:`, error);
    throw error;
  }
}

// Delete a settings snapshot
export async function deleteSnapshot(id: string): Promise<boolean> {
  try {
    await ensureSnapshotsDir();

    const filename = `snapshot-${id}.json`;
    const filePath = join(SNAPSHOTS_DIR, filename);

    if (!existsSync(filePath)) {
      console.warn(`Snapshot with ID ${id} not found for deletion`);
      return false;
    }

    await fs.unlink(filePath);
    return true;
  } catch (error) {
    console.error(`Error deleting snapshot with ID ${id}:`, error);
    return false;
  }
}
</file>

<file path="src/main/services/WhisperStream.ts">
import { IpcEmitter } from '@electron-toolkit/typed-ipc/main';
import { ChildProcess, spawn } from 'child_process';
import { app, BrowserWindow } from 'electron';
import { existsSync, mkdirSync } from 'fs';
import { join } from 'path';
import ggmlMetal from '../../../resources/lib/ggml-metal.metal?asset&asarUnpack';
import ggmlStreamBin from '../../../resources/lib/stream?asset&asarUnpack';
import ggmlModelSmallEnQ51Bin from '../../../resources/models/ggml-small.en-q5_1.bin?asset&asarUnpack';
import type { IpcRendererEvent } from '../../types/ipc';
import { serviceLogger } from '../utils/logger';
import { startPowerSaveBlocker } from '../utils/startPowerSaveBlocker';

const emitter = new IpcEmitter<IpcRendererEvent>();

// Keep track of the stream process
let activeStreamProcess: ChildProcess | null = null;

interface StreamOptions {
  name: string;
  model: string;
  metal: string;
  threads: number;
  step: number;
  length: number;
  keep: number;
  maxTokens: number;
  saveAudio: boolean;
}

const DEFAULT_OPTIONS: StreamOptions = {
  name: 'whisper-ccp-stream',
  model: ggmlModelSmallEnQ51Bin,
  metal: ggmlMetal,
  threads: 8,
  step: 800,
  length: 5000,
  keep: 300,
  maxTokens: 64,
  saveAudio: true,
};

/**
 * Creates and manages a child process for real-time audio stream transcription.
 *
 * @param mainWindow - The Electron main window instance to send transcription events
 * @param options - Optional configuration for the stream process
 * @returns The spawned child process instance
 *
 * The process handles:
 * - Spawning the stream executable with model and configuration parameters
 * - Streaming transcription data back to the main window
 * - Error handling and status updates
 * - Process lifecycle management
 */
export function spawnWhisperStream(
  mainWindow: BrowserWindow,
  options: Partial<StreamOptions> = {},
  printTranscription: boolean = false,
): ChildProcess {
  const mergedOptions = { ...DEFAULT_OPTIONS, ...options };

  const log = {
    msg: (message: string | object): void => {
      const text = typeof message === 'object' ? JSON.stringify(message, null, 2) : message;
      serviceLogger.debug(`[${mergedOptions.name}] ${text}`);
    },
    toWindow: (message: string): void => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        serviceLogger.debug(`[${mergedOptions.name}] [send] ${message}`);
        sendToWindowIfAvailable('whisper-ccp-stream:status', message);
      }
    },
    error: (message: string | object): void => {
      const text = typeof message === 'object' ? JSON.stringify(message, null, 2) : message;
      serviceLogger.error(`[${mergedOptions.name}] [error] ${text}`);
    },
  };

  const sendToWindowIfAvailable = (channel: keyof IpcRendererEvent, message: string): void => {
    if (mainWindow && !mainWindow.isDestroyed()) {
      emitter.send(mainWindow.webContents, channel, message);
    } else {
      log.error(`mainWindow Unavailable! Message: ${message}`);
    }
  };

  // Create audio directory in userData if it doesn't exist
  const audioDir = join(app.getPath('userData'), 'audio');
  if (!existsSync(audioDir)) {
    mkdirSync(audioDir, { recursive: true });
  }

  const spawnOptions = { cwd: audioDir };
  const args = [
    '--model',
    mergedOptions.model,
    '-t',
    mergedOptions.threads.toString(),
    '--step',
    mergedOptions.step.toString(),
    '--length',
    mergedOptions.length.toString(),
    '--keep',
    mergedOptions.keep.toString(),
    '--max-tokens',
    mergedOptions.maxTokens.toString(),
  ];

  if (mergedOptions.saveAudio) {
    args.push('--save-audio');
  }

  log.msg(`Starting in ${audioDir}`);
  log.msg(`Command: ${ggmlStreamBin} ${args.join(' ')}`);

  const stopPowerSaveBlocker = startPowerSaveBlocker(log.toWindow);

  const ls = spawn(ggmlStreamBin, args, spawnOptions);
  activeStreamProcess = ls;

  ls.stdout.on('data', (data: Buffer) => {
    const string = new TextDecoder().decode(data);
    if (printTranscription) {
      log.msg(`stdout: ${string}`);
    }
    sendToWindowIfAvailable('whisper-ccp-stream:transcription', string);
  });

  ls.stderr.on('data', (info: Buffer) => {
    const string = new TextDecoder().decode(info);
    log.toWindow(string);
  });

  ls.on('error', (error: Error) => {
    log.error(`Process error: ${error.message}`);
    log.toWindow(error.message);
  });

  ls.on('close', (code: number | null) => {
    log.error(`Process exited with code ${code}`);
    activeStreamProcess = null;
    stopPowerSaveBlocker();
  });

  return ls;
}

/**
 * Get the currently active stream process, if any
 */
export function getActiveStreamProcess(): ChildProcess | null {
  return activeStreamProcess;
}

/**
 * Stop the currently active stream process, if any
 */
export function stopStreamProcess(): void {
  if (activeStreamProcess) {
    activeStreamProcess.kill();
    activeStreamProcess = null;
  }
}
</file>

<file path="src/main/utils/applicationFolder.ts">
import { app, dialog } from 'electron';

/**
 * Checks if the app is in the Applications folder on macOS and prompts the user to move it if not.
 * Only runs on macOS and when the app is not in development mode.
 */
export function checkApplicationFolder(isDev: () => boolean): void {
  // Only run on macOS and when app is packaged (not in development)
  if (process.platform !== 'darwin' || isDev()) {
    return;
  }

  // Check if the app is already in the Applications folder
  if (!app.isInApplicationsFolder()) {
    const dialogOpts = {
      type: 'question' as const,
      buttons: ['Move to Applications', 'Do Not Move'],
      defaultId: 0,
      title: 'Move to Applications folder?',
      message: 'Would you like to move this app to your Applications folder?',
    };

    dialog.showMessageBox(dialogOpts).then((returnValue) => {
      if (returnValue.response === 0) {
        try {
          app.moveToApplicationsFolder({
            conflictHandler: (conflictType) => {
              if (conflictType === 'exists') {
                const choice = dialog.showMessageBoxSync({
                  type: 'question' as const,
                  buttons: ['Cancel', 'Replace'],
                  defaultId: 0,
                  message:
                    'An app with the same name already exists in the Applications folder. Do you want to replace it?',
                });
                return choice === 1; // Return true to continue (replace), false to cancel
              }
              return true; // Continue for other conflict types
            },
          });
        } catch (error) {
          console.error('Failed to move to Applications folder:', error);
        }
      }
    });
  }
}
</file>

<file path="src/main/utils/audioRecorder.ts">
import { PvRecorder } from '@picovoice/pvrecorder-node';
import { writeFileSync } from 'fs';
import { WaveFile } from 'wavefile';

interface AudioFrame extends Int16Array {
  readonly length: number;
}

/**
 * @deprecated AudioRecorder is deprecated. WhisperSpream process automaticaly records now during transcription.
 *
 * AudioRecorder handled real-time audio recording and transcription using PvRecorder.
 * It captured audio in frames, converted them to WAV format, and processed them through
 * Whisper for transcription.
 *
 * Deprecated Features:
 * - Real-time audio frame collection
 * - Automatic WAV file generation
 * - Integration with Whisper transcription
 * - Device management
 *
 * Note: The WhisperSpream process now records audio. Please migrate to it for all recording functionality.
 */
export class AudioRecorder {
  private frames: AudioFrame[];
  private recorder: PvRecorder | null;
  private readonly frameSize: number;
  private readonly deviceIndex: number;

  constructor(frameSize = 512, deviceIndex = 1) {
    this.frames = [];
    this.recorder = null;
    this.frameSize = frameSize;
    this.deviceIndex = deviceIndex;
  }

  getAvailableDevices(): string[] {
    return PvRecorder.getAvailableDevices();
  }

  async start(): Promise<void> {
    this.recorder = new PvRecorder(this.frameSize, this.deviceIndex);
    console.log(`Using PvRecorder version: ${this.recorder.version}`);
    this.recorder.start();

    while (this.recorder.isRecording) {
      const frame = await this.recorder.read();
      this.frames.push(frame as AudioFrame);

      if (this.frames.length > 200) {
        await this.saveAndTranscribe();
        this.frames.length = 0;
      }
    }
  }

  async saveAndTranscribe(): Promise<string> {
    if (!this.recorder) {
      throw new Error('Recorder not initialized');
    }

    const wav = new WaveFile();
    const audioData = new Int16Array(this.recorder.frameLength * this.frames.length);

    for (let i = 0; i < this.frames.length; i++) {
      audioData.set(this.frames[i], i * this.recorder.frameLength);
    }

    wav.fromScratch(1, this.recorder.sampleRate, '16', audioData);
    writeFileSync('test.wav', wav.toBuffer());
    console.log('Wrote test.wav');
    return 'test.wav';
  }

  stop(): void {
    if (this.recorder) {
      this.recorder.stop();
      this.recorder.release();
      this.recorder = null;
    }
  }
}
</file>

<file path="src/main/utils/helper.ts">
import { app, shell } from 'electron';
import { existsSync, mkdirSync } from 'fs';
import { join } from 'path/posix';

export const isDev = (): boolean => !app.isPackaged;

export const isMac = (): boolean => process.platform === 'darwin';

export function openPdfFolder(): boolean {
  const pdfDir = join(app.getPath('userData'), 'pdfs');
  const folderExists = existsSync(pdfDir);
  if (!folderExists) {
    mkdirSync(pdfDir, { recursive: true });
  }
  shell.openPath(pdfDir);
  return folderExists;
}
</file>

<file path="src/main/utils/logger.ts">
import { app } from 'electron';
import log from 'electron-log/main';
import { join } from 'path';

// Configure log file path
const LOG_PATH = app.isPackaged
  ? join(app.getPath('userData'), 'logs/main.log')
  : join(process.cwd(), 'logs/main.log');

// Initialize the logger for any renderer process
log.initialize();

// Configure file transport
log.transports.file.resolvePathFn = (): string => LOG_PATH;
log.transports.file.level = 'info';
log.transports.file.format = '[{y}-{m}-{d} {h}:{i}:{s}.{ms}] [{level}] {scope} {text}';

// Configure console transport
log.transports.console.level = 'debug';
log.transports.console.format = '{h}:{i}:{s}.{ms} › {scope} {text}';

// Enable IPC transport for development
if (!app.isPackaged) {
  log.transports.ipc.level = 'debug';
}

// Create scoped loggers for different parts of the application
export const mainLogger = log.scope('main');
export const printLogger = log.scope('print');
export const windowLogger = log.scope('window');
export const ipcLogger = log.scope('ipc');
export const serviceLogger = log.scope('service');

// Export the base logger as default
export default log;
</file>

<file path="src/main/utils/simulateTranscriptForDevTesting.ts">
import { IpcEmitter } from '@electron-toolkit/typed-ipc/main';
import { BrowserWindow } from 'electron';
import type { IpcRendererEvent } from '../../types/ipc';

const emitter = new IpcEmitter<IpcRendererEvent>();
interface SimulationController {
  start: () => void;
  stop: () => void;
}

let simulationInterval: NodeJS.Timeout | null = null;

/**
 * Simulates a real-time transcript stream for development testing purposes.
 * Creates a controlled environment that generates random transcript messages
 * alternating between natural phrases and unwanted segments at specified intervals.
 *
 * @param mainWindow - The Electron main window to send messages to
 * @param sendMessageEvery - Interval in ms between messages
 * @param balance - Probability (0-1) of generating unwanted segments vs natural phrases
 * @returns Controller object with start() and stop() methods to manage simulation
 */
export function simulatedTranscriptController(
  mainWindow: BrowserWindow,
  sendMessageEvery = 1800,
  balance = 0.2,
): SimulationController {
  // Words that are saved in the printed transcript
  const naturalPhrases: string[] = [
    // Complete thoughts
    'I hope you all enjoyed that',
    "Let's continue with some questions",
    'Maybe we can talk about this',
    "That's an interesting point",
    "Let's move on to the next topic",
    'I would like to ask you',
    'Can you tell us more about that',
    'What do you think about',

    // Questions and discussion starters
    'How do you feel about',
    'What are your thoughts on',
    'Could you explain why',
    'Do you believe that',

    // Fragments and transitions
    "Well that's exactly how",
    'Back to our previous point',
    'Speaking of which',
    'As I was saying before',
    'Moving on to',
    'Interesting perspective on',

    // Radio show specific
    "We're going to continue with some music now",
    "Let's take a short break",
    'Back after these messages',
    'Thanks for joining us today',
    'Coming up next',

    // Filler and thinking phrases
    'Um',
    'Well',
    'You know',
    'I mean',
    'Actually',
    'Sort of',
    'Kind of',
    'Like',
    'So basically',
    'The thing is',
    "What I'm trying to say is",
  ];

  // Segments that are typicaly produced by whisper and are ignored by the print preview
  const unwantedSegments: string[] = [
    '[ Silence ]',
    '[silence]',
    '[BLANK_AUDIO]',
    '[ [ [ [',
    '[ [ [',
    '[ [',
    '[',
    '(buzzer)',
    '(buzzing)',
    '.',
  ];

  function getRandomMessage(): string {
    // 20% chance for unwanted segments
    if (Math.random() < balance) {
      return unwantedSegments[Math.floor(Math.random() * unwantedSegments.length)];
    }

    // Generate a more natural sounding message
    const wordCount = Math.floor(Math.random() * 3) + 1; // 1-3 phrases for variety
    const sentence: string[] = [];
    for (let i = 0; i < wordCount; i++) {
      sentence.push(naturalPhrases[Math.floor(Math.random() * naturalPhrases.length)]);
    }
    return sentence.join(' ');
  }

  function simulateStream(): void {
    // Clear any existing interval
    if (simulationInterval) {
      clearInterval(simulationInterval);
      simulationInterval = null;
    }

    simulationInterval = setInterval(() => {
      if (!mainWindow || mainWindow.isDestroyed()) {
        if (simulationInterval) {
          clearInterval(simulationInterval);
          simulationInterval = null;
        }
        return;
      }

      const message = getRandomMessage();

      // Every 3-5 messages, send a NEW message
      if (Math.random() < 0.4) {
        emitter.send(mainWindow.webContents, 'whisper-ccp-stream:transcription', `${message}NEW`);
      } else {
        emitter.send(mainWindow.webContents, 'whisper-ccp-stream:transcription', message);
      }
    }, sendMessageEvery);

    // Clean up interval when window is closed or reloaded
    mainWindow.on('closed', () => {
      if (simulationInterval) {
        clearInterval(simulationInterval);
        simulationInterval = null;
      }
    });
  }

  return {
    start: simulateStream,
    stop: (): void => {
      if (simulationInterval) {
        clearInterval(simulationInterval);
        simulationInterval = null;
      }
    },
  };
}
</file>

<file path="src/main/utils/startPowerSaveBlocker.ts">
import { powerSaveBlocker } from 'electron';

export function startPowerSaveBlocker(logtoWindow: (message: string) => void): () => void {
  const id = powerSaveBlocker.start('prevent-display-sleep');
  if (powerSaveBlocker.isStarted(id)) {
    logtoWindow('✅ Power save blocker started');
  } else {
    logtoWindow('❌ Power save blocker failed to start');
  }
  return () => {
    powerSaveBlocker.stop(id);
    logtoWindow('❌ Power save blocker stopped');
  };
}
</file>

<file path="src/main/window/EditorWindow.ts">
import { BrowserWindow, WebContents, app } from 'electron';
import os from 'os';
import { join } from 'path';
import icon from '../../../resources/favicon.png?asset';
import { mainWindowManager } from './MainWindow';

export class EditorWindow {
  private editorWindows: BrowserWindow[] = [];

  public createEditorWindow(
    options: { initialContent?: string; language?: 'css' | 'html' } = {},
  ): BrowserWindow {
    const mainWindow = mainWindowManager.getOrCreateMainWindow();
    const window = new BrowserWindow({
      width: 800,
      height: 600,
      // titleBarStyle: 'hidden',
      // transparent: true,
      // frame: false,
      parent: mainWindow,
      webPreferences: {
        nodeIntegration: true,
        preload: join(__dirname, '../preload/index.js'),
      },
      icon,
      show: false,
    });

    // Set default represented filename to home directory
    window.setRepresentedFilename(os.homedir());

    // Load the editor window
    if (!app.isPackaged && process.env['ELECTRON_RENDERER_URL']) {
      window.loadURL(process.env['ELECTRON_RENDERER_URL'] + '/editor');
    } else {
      window.loadFile(join(__dirname, '../renderer/editor.html'));
    }

    // Handle window ready
    window.once('ready-to-show', () => {
      window.show();

      // Send initial content and language if provided
      if (options.initialContent || options.language) {
        window.webContents.send('editor:init', {
          content: options.initialContent || '',
          language: options.language || 'css',
        });
      }
    });

    // Handle window closing
    window.on('closed', () => {
      const index = this.editorWindows.indexOf(window);
      if (index > -1) {
        this.editorWindows.splice(index, 1);
      }
    });

    this.editorWindows.push(window);
    return window;
  }

  public getEditorWindowFromWebContents(webContents: WebContents): BrowserWindow | null {
    return (
      this.editorWindows.find(
        (win) => !win.isDestroyed() && win.webContents.id === webContents.id,
      ) || null
    );
  }

  public getEditorWindows(): BrowserWindow[] {
    // Clean up any destroyed windows
    this.editorWindows = this.editorWindows.filter((window) => !window.isDestroyed());
    return this.editorWindows;
  }

  public setEditorLanguage(window: BrowserWindow, language: 'css' | 'html'): void {
    if (!window.isDestroyed()) {
      window.webContents.send('editor:setLanguage', language);
    }
  }

  public cleanup(): void {
    for (const window of this.editorWindows) {
      if (!window.isDestroyed()) {
        window.close();
      }
    }
    this.editorWindows = [];
  }
}

// Create a singleton instance
export const editorWindowManager = new EditorWindow();
</file>

<file path="src/main/window/MainWindow.ts">
import { BrowserWindow, app } from 'electron';
import { join } from 'path';
import icon from '../../../resources/favicon.png?asset';
import { printQueue } from '../print/PrintQueue';
import { spawnWhisperStream } from '../services/WhisperStream';
import { isDev } from '../utils/helper';
import { windowLogger } from '../utils/logger';
import { simulatedTranscriptController } from '../utils/simulateTranscriptForDevTesting';
import { printWindowManager } from './PrintWindow';

/**
 * Manages the main window instance, handling creation, recreation, and state
 */
export class MainWindow {
  private mainWindow: BrowserWindow | null = null;
  private simulationController: ReturnType<typeof simulatedTranscriptController> | null = null;

  /**
   * Creates a main window if one doesn't exist or returns the existing one
   */
  public getOrCreateMainWindow(): BrowserWindow {
    if (this.mainWindow && !this.mainWindow.isDestroyed()) {
      return this.mainWindow;
    }

    const options = {
      width: 1200,
      height: 950,
      webPreferences: {
        titleBarStyle: {
          hiddenInset: true,
        },
        nodeIntegration: true,
        preload: join(__dirname, '../preload/index.js'),
      },
      icon,
      show: false,
    };

    this.mainWindow = new BrowserWindow(options);

    if (isDev()) {
      this.mainWindow.webContents.openDevTools();
    }

    // Load the app
    if (!app.isPackaged && process.env['ELECTRON_RENDERER_URL']) {
      this.mainWindow.loadURL(process.env['ELECTRON_RENDERER_URL']);
    } else {
      this.mainWindow.loadFile(join(__dirname, '../renderer/index.html'));
    }

    // Window event handlers
    let isWindowShown = false;
    let isContentLoaded = false;

    const checkAndStartProcesses = (): void => {
      if (isWindowShown && isContentLoaded && this.mainWindow) {
        this.startProcesses();
      }
    };

    this.mainWindow.once('ready-to-show', () => {
      this.mainWindow?.show();
      isWindowShown = true;
      checkAndStartProcesses();
    });

    this.mainWindow.webContents.once('did-finish-load', () => {
      isContentLoaded = true;
      checkAndStartProcesses();
    });

    // Handle window closing
    this.mainWindow.on('closed', () => {
      // If there are active print jobs, show the print window
      if (printQueue.hasActiveJobs()) {
        printWindowManager.showPrintWindow();
      }

      // Clean up stream process
      if (global.streamProcess) {
        global.streamProcess.kill();
        global.streamProcess = null;
      }

      this.mainWindow = null;
    });

    return this.mainWindow;
  }

  /**
   * Gets current main window instance
   */
  public getMainWindow(): BrowserWindow | null {
    return this.mainWindow;
  }

  /**
   * Shows the main window
   */
  public showMainWindow(): void {
    const window = this.getOrCreateMainWindow();
    if (window && !window.isDestroyed()) {
      window.show();
    }
  }

  /**
   * Starts the processes needed for the application
   */
  private startProcesses(): void {
    if (!this.mainWindow) return;

    if (process.argv.includes('--simulate')) {
      windowLogger.info('Running in simulation mode');
      this.simulationController = simulatedTranscriptController(this.mainWindow);
      this.simulationController.start();
    } else {
      // Store the stream process in the global variable for access across the app
      global.streamProcess = spawnWhisperStream(this.mainWindow);
    }
  }

  /**
   * Cleans up resources when application is quitting
   */
  public cleanup(): void {
    if (this.simulationController) {
      this.simulationController.stop();
      this.simulationController = null;
    }

    // Clean up stream process
    if (global.streamProcess) {
      global.streamProcess.kill();
      global.streamProcess = null;
    }
  }
}

// Create a singleton instance
export const mainWindowManager = new MainWindow();
</file>

<file path="src/main/window/PrintWindow.ts">
import { IpcEmitter } from '@electron-toolkit/typed-ipc/main';
import { BrowserWindow, app } from 'electron';
import { join } from 'path';
import { printJobSchema, type PrintJob } from '../../types';
import type { IpcRendererEvent } from '../../types/ipc';
import { isDev } from '../utils/helper';
import { windowLogger } from '../utils/logger';

const emitter = new IpcEmitter<IpcRendererEvent>();

/**
 * Manages the print window instance, handling creation, recreation, and state
 */
export class PrintWindowManager {
  private printWindow: BrowserWindow | null = null;
  private debuggerAttached = false;

  /**
   * Creates a print window if one doesn't exist or returns the existing one
   */
  public getOrCreatePrintWindow(): BrowserWindow {
    if (this.printWindow && !this.printWindow.isDestroyed()) {
      return this.printWindow;
    }

    const options = {
      width: 450,
      height: 650,
      show: isDev() || app.isPackaged,
      webPreferences: {
        scrollBounce: false,
        nodeIntegration: true,
        contextIsolation: false,
        preload: join(__dirname, '../preload/index.js'),
        sandbox: false,
      },
    };

    this.printWindow = new BrowserWindow(options);

    if (!app.isPackaged && process.env['ELECTRON_RENDERER_URL']) {
      this.printWindow.loadURL(`${process.env['ELECTRON_RENDERER_URL']}/debug.html`);
    } else {
      this.printWindow.loadFile(join(__dirname, '../renderer/debug.html'));
    }

    // Initialize debugger state for new window
    this.debuggerAttached = false;

    // Clean up debugger on window close
    this.printWindow.on('closed', () => {
      if (this.debuggerAttached && this.printWindow?.webContents) {
        try {
          this.printWindow.webContents.debugger.detach();
        } catch (error) {
          windowLogger.error('Failed to detach debugger:', error);
        }
        this.debuggerAttached = false;
      }
      this.printWindow = null;
    });

    return this.printWindow;
  }

  public async awaitWindowReady(): Promise<BrowserWindow> {
    const window = this.getOrCreatePrintWindow();
    if (!window || window.isDestroyed()) {
      throw new Error('Print window is not available');
    }

    if (window.webContents.isLoading()) {
      await new Promise<void>((resolve) => {
        const checkReady = setInterval(() => {
          if (!window.webContents.isLoading()) {
            clearInterval(checkReady);
            resolve();
          }
        }, 100);
      });
    }
    return this.enforcePrintWindow();
  }

  /**
   * Sends content to the print window for printing
   */
  public async sendJobToPrintWindow(printJob: PrintJob): Promise<void> {
    const printWindow = await this.awaitWindowReady();
    const cleanPrintJob = printJobSchema.parse(printJob);

    windowLogger.info(`Sending job ${cleanPrintJob.printId} to print window`);
    emitter.send(printWindow.webContents, 'PrintWindow:printJob', cleanPrintJob);
  }

  /**
   * Gets current print window instance
   */
  public getPrintWindow(): BrowserWindow | null {
    return this.printWindow;
  }

  /**
   * Shows the print window
   */
  public showPrintWindow(): void {
    const window = this.getOrCreatePrintWindow();
    if (window && !window.isDestroyed()) {
      window.show();
    }
  }

  private enforcePrintWindow(): BrowserWindow {
    if (this.printWindow && !this.printWindow.isDestroyed()) {
      return this.printWindow;
    }
    throw new Error('Print window is not available');
  }
}

// Create a singleton instance
export const printWindowManager = new PrintWindowManager();
</file>

<file path="src/main/index.ts">
import { electronApp, optimizer } from '@electron-toolkit/utils';
import { app, BrowserWindow } from 'electron';

import { setupEditorIPC } from './ipc/editor';
import { createMenu } from './menu';
import { printQueue } from './print/PrintQueue';
import { setupIpcHandlers } from './services/ipcHandlers';
import { checkApplicationFolder } from './utils/applicationFolder';
import { mainWindowManager } from './window/MainWindow';
import { printWindowManager } from './window/PrintWindow';

const isDev = (): boolean => !app.isPackaged;

// App initialization
app.whenReady().then(() => {
  // Set app user model id for windows
  electronApp.setAppUserModelId('com.electron');

  app.commandLine.appendSwitch('disable-renderer-backgrounding');

  // Default open or close DevTools by F12 in development
  app.on('browser-window-created', (_, window) => {
    optimizer.watchWindowShortcuts(window);
  });

  // Register IPC handlers
  setupIpcHandlers();

  // Initialize menu
  createMenu();

  // Setup IPC handlers
  setupEditorIPC();

  // Create the main window
  mainWindowManager.getOrCreateMainWindow();

  // Create the print window
  printWindowManager.getOrCreatePrintWindow();

  // Check if we should move to Applications folder
  checkApplicationFolder(isDev);

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      mainWindowManager.getOrCreateMainWindow();
    }
  });
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

// Cleanup on app quit
app.on('before-quit', () => {
  printQueue.cleanup();

  // Clean up the main window manager
  mainWindowManager.cleanup();
});
</file>

<file path="src/preload/index.d.ts">
import { ElectronAPI } from '@electron-toolkit/preload';

declare global {
  interface Window {
    electron: ElectronAPI;
    api: unknown;
  }
}
</file>

<file path="src/preload/index.ts">
import { electronAPI } from '@electron-toolkit/preload';
import { contextBridge } from 'electron';

// Custom APIs for renderer
const api = {};

// Use `contextBridge` APIs to expose Electron APIs to
// renderer only if context isolation is enabled, otherwise
// just add to the DOM global.
if (process.contextIsolated) {
  try {
    contextBridge.exposeInMainWorld('electron', electronAPI);
    contextBridge.exposeInMainWorld('api', api);
  } catch (error) {
    console.error(error);
  }
} else {
  // @ts-ignore (define in dts)
  window.electron = electronAPI;
  // @ts-ignore (define in dts)
  window.api = api;
}
</file>

<file path="src/preload/print.ts">
import { electronAPI } from '@electron-toolkit/preload';
import { contextBridge } from 'electron';

// Custom APIs for renderer
const api = {};

// Use `contextBridge` APIs to expose Electron APIs to
// renderer only if context isolation is enabled, otherwise
// just add to the DOM global.
if (process.contextIsolated) {
  try {
    contextBridge.exposeInMainWorld('electron', electronAPI);
    contextBridge.exposeInMainWorld('api', api);
  } catch (error) {
    console.error(error);
  }
} else {
  // @ts-ignore (define in dts)
  window.electron = electronAPI;
  // @ts-ignore (define in dts)
  window.api = api;
}
</file>

<file path="src/renderer/src/assets/input-defaults/editorCss.ts">
export default `.el {
  display: inline-block;
  //transform: skew(30deg, 2deg);
  line-height: $m2 * 3;
  // filter: drop-shadow(16px 16px 10px black);
  letter-spacing: $m5 * 1px;
  text-decoration: blue wavy underline $m1 * 5px;
  text-shadow: 2px 2px 10px red;
  // text-shadow: 5px 5px #000;
  // text-shadow: 1px 1px 2px red, 0 0 1em blue, 0 0 0.2em blue;

  
  // color: white;
  text-shadow: 1px 1px 4px black, 0 0 1em black, 0 0 10px black;

  // filter: url(#outline);
  font-family: NIKITA-Regular;

  background: rgba($bgR, $bgG, $bgB, $bgA);
  rotate: $r1 * 1deg;
  font-size: $fsz * 1em;
  font-family: NIKITA-Regular;
} 
`;
</file>

<file path="src/renderer/src/assets/input-defaults/editorSvgFilter.ts">
export default `<svg>
<filter id="glitch">
	<feTurbulence type="fractalNoise" baseFrequency="0.03 0.01" numOctaves="1" result="warp" id="turb"/>
	<feColorMatrix in="warp" result="huedturb" type="hueRotate" values="90">
	<animate attributeType="XML" attributeName="values" values="0;180;360" dur="6s"
                         repeatCount="indefinite"/>
	</feColorMatrix>
	<feDisplacementMap xChannelSelector="R" yChannelSelector="G" scale="30" in="SourceGraphic" in2="huedturb"/>
</filter>

<filter id="distort">
  <feTurbulence baseFrequency="0.01 0.01" numOctaves="1" result="noise"  />
  <feDisplacementMap in="SourceGraphic" in2="noise" scale="10" xChannelSelector="R" yChannelSelector="R">
</filter>

<filter id="grain">
  <feTurbulence type="turbulence"
    baseFrequency="0.1" numOctaves="2" result="turbulence"/>
  <feDisplacementMap in2="turbulence" in="SourceGraphic"
    scale="10" xChannelSelector="R" yChannelSelector="G" />
</filter>

<filter id="swoot">
	<feTurbulence type="turbulence" baseFrequency="0.015 0.1" numOctaves="2" seed="2" stitchTiles="stitch" x="0%" y="0%" width="100%" height="100%" result="turbulence"/>
	<feDisplacementMap in="SourceGraphic" in2="turbulence" scale="15" xChannelSelector="R" yChannelSelector="B" x="0%" y="0%" width="100%" height="100%" result="displacementMap1"/>
</filter>

<filter id="outline">
      <feMorphology operator="dilate" radius="12" in="SourceGraphic" result="THICKNESS" />
      <feComposite operator="out" in="THICKNESS" in2="SourceGraphic"></feComposite>
</filter>

<filter id="motion-blur">
	<feGaussianBlur in="SourceGraphic" stdDeviation="5,0" />
</filter>

<filter id="blobs" color-interpolation-filters="sRGB" x="-50%" y="-50%" height="200%" width="200%">
	<feOffset id="offset" in="SourceAlpha" dx="0" dy="0" result="SA-offset"/>
	<feGaussianBlur id="blur" in="SA-offset" stdDeviation="5.5" result="SA-o-blur"/>
	<feComponentTransfer in="SA-o-blur" result="SA-o-b-contIN">
	  <feFuncA id="contour" type="table" tableValues="0 0.05 0.15 0.45 0.7 0.85 0.95 1 0.95 0.85 0.7 0.45 0.15 0.05 0 0.05 0.15 0.45 0.7 0.85 0.95 1 0.95 0.85 0.7 0.45 0.15 0.05 0 0.05 0.15 0.45 0.7 0.85 0.95 1"/>
	</feComponentTransfer>
	<feComposite operator="in" in="SA-o-blur" in2="SA-o-b-contIN" result="SA-o-b-cont"/>
	<feComponentTransfer in="SA-o-b-cont" result="SA-o-b-c-sprd">
	  <feFuncA id="spread-ctrl" type="linear" slope="5.1"/>
	</feComponentTransfer>
	<feColorMatrix id="recolor" in="SA-o-b-c-sprd" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0" result="SA-o-b-c-s-recolor"/>
	<feTurbulence result="fNoise" type="fractalNoise" numOctaves="6" baseFrequency="1.98"/>
	<feColorMatrix in="fNoise" type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 7 -3" result="clipNoise"/>
	<feComposite id="noisemix" operator="arithmetic" in="SA-o-b-c-s-recolor" in2="clipNoise" k1="0" k2="1" result="SA-o-b-c-s-r-mix"/>
	<feMerge>
	  <feMergeNode in="SA-o-b-c-s-r-mix"/>
	  <feMergeNode in="SourceGraphic"/>
	</feMerge>
</filter>

<filter id="fire" x="-20%" y="-20%" width="140%" height="140%" filterUnits="objectBoundingBox" primitiveUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
  <feGaussianBlur stdDeviation="0 10" x="0%" y="0%" width="100%" height="100%" in="SourceGraphic" edgeMode="none" result="blur"/>
  <feTurbulence type="turbulence" baseFrequency="0.06 0.015" numOctaves="2" seed="2" stitchTiles="stitch" x="0%" y="0%" width="100%" height="100%" result="turbulence1"/>
  <feColorMatrix type="matrix" values="1 0 0 0 0
0 1 0 0 0
0 0 1 0 0
0 0 0 5 -1" x="0%" y="0%" width="100%" height="100%" in="turbulence1" result="colormatrix2"/>
  <feColorMatrix type="matrix" values="1 0 0 0 0
0 1 0 0 0
0 0 1 0 0
0 0 0 3 0" x="0%" y="0%" width="100%" height="100%" in="turbulence1" result="colormatrix3"/>
  <feComposite in="colormatrix2" in2="blur" operator="in" x="0%" y="0%" width="100%" height="100%" result="composite1"/>
  <feFlood flood-color="#ff853a" flood-opacity="1" x="0%" y="0%" width="100%" height="100%" result="flood1"/>
  <feComposite in="flood1" in2="composite1" operator="in" x="0%" y="0%" width="100%" height="100%" result="composite2"/>
  <feOffset dx="-5" dy="-20" x="0%" y="0%" width="100%" height="100%" in="composite2" result="offset1"/>
  <feMorphology operator="dilate" radius="0 10" x="0%" y="0%" width="100%" height="100%" in="offset1" result="morphology"/>
  <feDisplacementMap in="morphology" in2="turbulence1" scale="20" xChannelSelector="G" yChannelSelector="B" x="0%" y="0%" width="100%" height="100%" result="displacementMap1"/>
  <feComposite in="merge3" in2="colormatrix3" operator="out" x="0%" y="0%" width="100%" height="100%" result="composite3"/>
  <feFlood flood-color="#ff8422" flood-opacity="1" x="0%" y="0%" width="100%" height="100%" result="flood2"/>
  <feComposite in="flood2" in2="composite3" operator="in" x="0%" y="0%" width="100%" height="100%" result="composite4"/>
  <feMerge x="0%" y="0%" width="100%" height="100%" result="merge3">
          <feMergeNode in="displacementMap1"/>
      <feMergeNode in="SourceGraphic"/>
      <feMergeNode in="composite4"/>
  </feMerge>
</filter>

</svg>
`;
</file>

<file path="src/renderer/src/assets/input-defaults/inlineStyle.ts">
export default `.el {
  display: inline-block;
  //transform: skew(30deg, 2deg);
  line-height: $m2 * 3;
  // filter: drop-shadow(16px 16px 10px black);
  letter-spacing: $m5 * 1px;
  text-decoration: blue wavy underline $m1 * 5px;
  text-shadow: 2px 2px 10px red;
  // text-shadow: 5px 5px #000;
  // text-shadow: 1px 1px 2px red, 0 0 1em blue, 0 0 0.2em blue;

  
  // color: white;
  text-shadow: 1px 1px 4px black, 0 0 1em black, 0 0 10px black;

  // filter: url(#outline);
  font-family: NIKITA-Regular;

  background: rgba($bgR, $bgG, $bgB, $bgA);
  rotate: $r1 * 1deg;
  font-size: $fsz * 1em;
  font-family: NIKITA-Regular;
} 
`;
</file>

<file path="src/renderer/src/assets/input-defaults/input.json">
{
  "keys": {
    "a": {
      "function": "increaseFontSize"
    },
    "s": {
      "function": "decreaseFontSize"
    },
    "q": {
      "function": "addImage"
    }
  },
  "controllers": [
    {
      "name": "BGRed",
      "var": "bgR",
      "value": 0,
      "default": 0,
      "step": 5,
      "knobNR": 0,
      "range": [0, 255]
    },
    {
      "name": "BGGreen",
      "var": "bgG",
      "value": 0,
      "default": 0,
      "step": 5,
      "knobNR": 1,
      "range": [0, 255]
    },
    {
      "name": "BGBlue",
      "var": "bgB",
      "value": 0,
      "default": 0,
      "step": 5,
      "knobNR": 2,
      "range": [0, 255]
    },
    {
      "name": "BGAlpha",
      "var": "bgA",
      "value": 0,
      "default": 0,
      "step": 0.05,
      "knobNR": 3,
      "range": [0, 1]
    },
    {
      "name": "midi1",
      "var": "m1",
      "value": 1,
      "default": 1,
      "step": 0.1,
      "knobNR": 4,
      "range": [0, 1]
    },
    {
      "name": "midi2",
      "var": "m2",
      "value": 1,
      "default": 1,
      "step": 0.1,
      "knobNR": 5,
      "range": [0, 1]
    },
    {
      "name": "midi3",
      "var": "m3",
      "value": 1,
      "default": 1,
      "step": 0.1,
      "knobNR": 6,
      "range": [0, 1]
    },
    {
      "name": "midi4",
      "var": "m4",
      "value": 1,
      "default": 1,
      "step": 0.1,
      "knobNR": 7,
      "range": [0, 1]
    },
    {
      "name": "midi5",
      "var": "m5",
      "value": 1,
      "default": 1,
      "step": 0.1,
      "knobNR": 8,
      "range": [0, 10]
    },
    {
      "name": "midi6",
      "var": "m6",
      "value": 1,
      "default": 1,
      "step": 0.1,
      "knobNR": 9,
      "range": [0, 10]
    },
    {
      "name": "midi7",
      "var": "m7",
      "value": 1,
      "default": 1,
      "step": 0.1,
      "knobNR": 10,
      "range": [0, 10]
    },
    {
      "name": "midi8",
      "var": "m8",
      "value": 1,
      "default": 1,
      "step": 0.1,
      "knobNR": 11,
      "range": [0, 10]
    },

    {
      "name": "Fontsize",
      "var": "fsz",
      "value": 1,
      "default": 1,
      "step": 0.1,
      "knobNR": 15,
      "range": [0.5, 4]
    },
    {
      "name": "rotation",
      "var": "r1",
      "value": 0,
      "default": 0,
      "step": 1,
      "knobNR": 12,
      "range": [-20, 20]
    }
  ]
}
</file>

<file path="src/renderer/src/assets/input-defaults/svgFilters.ts">
export default `<svg>
<filter id="glitch">
	<feTurbulence type="fractalNoise" baseFrequency="0.03 0.01" numOctaves="1" result="warp" id="turb"/>
	<feColorMatrix in="warp" result="huedturb" type="hueRotate" values="90">
	<animate attributeType="XML" attributeName="values" values="0;180;360" dur="6s"
                         repeatCount="indefinite"/>
	</feColorMatrix>
	<feDisplacementMap xChannelSelector="R" yChannelSelector="G" scale="30" in="SourceGraphic" in2="huedturb"/>
</filter>

<filter id="distort">
  <feTurbulence baseFrequency="0.01 0.01" numOctaves="1" result="noise"  />
  <feDisplacementMap in="SourceGraphic" in2="noise" scale="10" xChannelSelector="R" yChannelSelector="R">
</filter>

<filter id="grain">
  <feTurbulence type="turbulence"
    baseFrequency="0.1" numOctaves="2" result="turbulence"/>
  <feDisplacementMap in2="turbulence" in="SourceGraphic"
    scale="10" xChannelSelector="R" yChannelSelector="G" />
</filter>

<filter id="swoot">
	<feTurbulence type="turbulence" baseFrequency="0.015 0.1" numOctaves="2" seed="2" stitchTiles="stitch" x="0%" y="0%" width="100%" height="100%" result="turbulence"/>
	<feDisplacementMap in="SourceGraphic" in2="turbulence" scale="15" xChannelSelector="R" yChannelSelector="B" x="0%" y="0%" width="100%" height="100%" result="displacementMap1"/>
</filter>

<filter id="outline">
      <feMorphology operator="dilate" radius="12" in="SourceGraphic" result="THICKNESS" />
      <feComposite operator="out" in="THICKNESS" in2="SourceGraphic"></feComposite>
</filter>

<filter id="motion-blur">
	<feGaussianBlur in="SourceGraphic" stdDeviation="5,0" />
</filter>

<filter id="blobs" color-interpolation-filters="sRGB" x="-50%" y="-50%" height="200%" width="200%">
	<feOffset id="offset" in="SourceAlpha" dx="0" dy="0" result="SA-offset"/>
	<feGaussianBlur id="blur" in="SA-offset" stdDeviation="5.5" result="SA-o-blur"/>
	<feComponentTransfer in="SA-o-blur" result="SA-o-b-contIN">
	  <feFuncA id="contour" type="table" tableValues="0 0.05 0.15 0.45 0.7 0.85 0.95 1 0.95 0.85 0.7 0.45 0.15 0.05 0 0.05 0.15 0.45 0.7 0.85 0.95 1 0.95 0.85 0.7 0.45 0.15 0.05 0 0.05 0.15 0.45 0.7 0.85 0.95 1"/>
	</feComponentTransfer>
	<feComposite operator="in" in="SA-o-blur" in2="SA-o-b-contIN" result="SA-o-b-cont"/>
	<feComponentTransfer in="SA-o-b-cont" result="SA-o-b-c-sprd">
	  <feFuncA id="spread-ctrl" type="linear" slope="5.1"/>
	</feComponentTransfer>
	<feColorMatrix id="recolor" in="SA-o-b-c-sprd" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0" result="SA-o-b-c-s-recolor"/>
	<feTurbulence result="fNoise" type="fractalNoise" numOctaves="6" baseFrequency="1.98"/>
	<feColorMatrix in="fNoise" type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 7 -3" result="clipNoise"/>
	<feComposite id="noisemix" operator="arithmetic" in="SA-o-b-c-s-recolor" in2="clipNoise" k1="0" k2="1" result="SA-o-b-c-s-r-mix"/>
	<feMerge>
	  <feMergeNode in="SA-o-b-c-s-r-mix"/>
	  <feMergeNode in="SourceGraphic"/>
	</feMerge>
</filter>

<filter id="fire" x="-20%" y="-20%" width="140%" height="140%" filterUnits="objectBoundingBox" primitiveUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
  <feGaussianBlur stdDeviation="0 10" x="0%" y="0%" width="100%" height="100%" in="SourceGraphic" edgeMode="none" result="blur"/>
  <feTurbulence type="turbulence" baseFrequency="0.06 0.015" numOctaves="2" seed="2" stitchTiles="stitch" x="0%" y="0%" width="100%" height="100%" result="turbulence1"/>
  <feColorMatrix type="matrix" values="1 0 0 0 0
0 1 0 0 0
0 0 1 0 0
0 0 0 5 -1" x="0%" y="0%" width="100%" height="100%" in="turbulence1" result="colormatrix2"/>
  <feColorMatrix type="matrix" values="1 0 0 0 0
0 1 0 0 0
0 0 1 0 0
0 0 0 3 0" x="0%" y="0%" width="100%" height="100%" in="turbulence1" result="colormatrix3"/>
  <feComposite in="colormatrix2" in2="blur" operator="in" x="0%" y="0%" width="100%" height="100%" result="composite1"/>
  <feFlood flood-color="#ff853a" flood-opacity="1" x="0%" y="0%" width="100%" height="100%" result="flood1"/>
  <feComposite in="flood1" in2="composite1" operator="in" x="0%" y="0%" width="100%" height="100%" result="composite2"/>
  <feOffset dx="-5" dy="-20" x="0%" y="0%" width="100%" height="100%" in="composite2" result="offset1"/>
  <feMorphology operator="dilate" radius="0 10" x="0%" y="0%" width="100%" height="100%" in="offset1" result="morphology"/>
  <feDisplacementMap in="morphology" in2="turbulence1" scale="20" xChannelSelector="G" yChannelSelector="B" x="0%" y="0%" width="100%" height="100%" result="displacementMap1"/>
  <feComposite in="merge3" in2="colormatrix3" operator="out" x="0%" y="0%" width="100%" height="100%" result="composite3"/>
  <feFlood flood-color="#ff8422" flood-opacity="1" x="0%" y="0%" width="100%" height="100%" result="flood2"/>
  <feComposite in="flood2" in2="composite3" operator="in" x="0%" y="0%" width="100%" height="100%" result="composite4"/>
  <feMerge x="0%" y="0%" width="100%" height="100%" result="merge3">
          <feMergeNode in="displacementMap1"/>
      <feMergeNode in="SourceGraphic"/>
      <feMergeNode in="composite4"/>
  </feMerge>
</filter>

</svg>
`;
</file>

<file path="src/renderer/src/assets/global.css">
@font-face {
  font-family: SpaceMono;
  src: url(SpaceMono-Regular.ttf);
  font-weight: normal;
}
@font-face {
  font-family: SpaceMono;
  src: url(SpaceMono-Bold.ttf);
  font-weight: bold;
}

:root {
  --grain: url('data:image/svg+xml,    <svg xmlns="http://www.w3.org/2000/svg">      <filter id="grain">       <feTurbulence type="turbulence" baseFrequency="0.5" numOctaves="2" result="turbulence"/>       <feDisplacementMap in2="turbulence" in="SourceGraphic" scale="3" xChannelSelector="R" yChannelSelector="G"/>       </filter>   </svg>#grain');
  --grainTest: url('data:image/svg+xml,    <svg xmlns="http://www.w3.org/2000/svg">      <filter id="filter" x="-20%" y="-20%" width="140%" height="140%" filterUnits="objectBoundingBox" primitiveUnits="userSpaceOnUse" color-interpolation-filters="linearRGB">   <feTurbulence type="turbulence" baseFrequency="0.015 0.1" numOctaves="2" seed="2" stitchTiles="stitch" x="0%" y="0%" width="100%" height="100%" result="turbulence"/>   <feDisplacementMap in="SourceGraphic" in2="turbulence" scale="15" xChannelSelector="R" yChannelSelector="B" x="0%" y="0%" width="100%" height="100%" result="displacementMap1"/>   </filter> |  </svg>#filter');
  --grain-min: url('data:image/svg+xml,    <svg xmlns="http://www.w3.org/2000/svg">      <filter id="grain">       <feTurbulence type="turbulence" baseFrequency="0.5" numOctaves="2" result="turbulence"/>       <feDisplacementMap in2="turbulence" in="SourceGraphic" scale="1" xChannelSelector="R" yChannelSelector="G"/>       </filter>   </svg>#grain');
}

html,
body {
  position: relative;
  width: 100%;
  height: 100%;
}

body {
  color: #333;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family:
    -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell,
    'Helvetica Neue', sans-serif;
}

a {
  color: rgb(0, 100, 200);
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

a:visited {
  color: rgb(0, 80, 160);
}

label {
  display: block;
}

input,
button,
select,
textarea {
  font-family: inherit;
  font-size: inherit;
  -webkit-padding: 0.4em 0;
  padding: 0.4em;
  margin: 0 0 0.5em 0;
  box-sizing: border-box;
  border: 1px solid #ccc;
  border-radius: 2px;
}

input:disabled {
  color: #ccc;
}

button {
  color: #333;
  background-color: #f4f4f4;
  outline: none;
}

button:disabled {
  color: #999;
}

button:not(:disabled):active {
  background-color: #ddd;
}

button:focus {
  border-color: #666;
}
</file>

<file path="src/renderer/src/components/codeEditor/css/commands/LivecodingKeymapExtra.ts">
import { Prec, type Extension, type StateCommand } from '@codemirror/state';
import { EditorView, keymap, type KeyBinding } from '@codemirror/view';

/**
 * Find the block boundaries from the current cursor position
 */
function findBlockBoundaries(state: EditorView['state']): { startLine: number; endLine: number } {
  const selection = state.selection.main;
  const cursor = selection.head;
  const cursorLine = state.doc.lineAt(cursor);

  // Find the block start (look for non-empty lines going up)
  let startLine = cursorLine.number;
  while (startLine > 1) {
    const line = state.doc.line(startLine - 1);
    const trimmed = line.text.trim();

    // Stop if we find an empty line or a line that looks like a block delimiter
    if (trimmed === '' || trimmed === '}' || trimmed === '{') {
      break;
    }

    startLine--;
  }

  // Find the block end (look for non-empty lines going down)
  let endLine = cursorLine.number;
  while (endLine < state.doc.lines) {
    const line = state.doc.line(endLine + 1);
    const trimmed = line.text.trim();

    // Stop if we find an empty line or closing brace
    if (trimmed === '' || trimmed === '}') {
      break;
    }

    endLine++;
  }

  return { startLine, endLine };
}

/**
 * Command to jump to the previous block
 */
const jumpToPreviousBlock: StateCommand = ({ state, dispatch }) => {
  // Find the current block boundaries
  const { startLine } = findBlockBoundaries(state);

  // If we're already at the first line, can't go further up
  if (startLine <= 1) return false;

  // Get the current cursor position to maintain horizontal position
  const selection = state.selection.main;
  const cursorPos = selection.head;
  const cursorLine = state.doc.lineAt(cursorPos);
  const cursorCol = cursorPos - cursorLine.from;

  // Look for the previous block boundary by going up from the current block's start
  let targetLine = startLine - 1;

  // Skip any empty lines or braces
  while (targetLine > 1) {
    const line = state.doc.line(targetLine);
    const trimmed = line.text.trim();
    if (trimmed !== '' && trimmed !== '}' && trimmed !== '{') {
      break;
    }
    targetLine--;
  }

  // If we found a valid target line, move the cursor there
  if (targetLine >= 1) {
    const line = state.doc.line(targetLine);

    // Calculate the new cursor position, maintaining the same column position
    // but clamping it to the line length to avoid going past the end
    const maxCol = line.length;
    const newCol = Math.min(cursorCol, maxCol);
    const newPos = line.from + newCol;

    const transaction = state.update({
      selection: { anchor: newPos, head: newPos },
    });
    dispatch(transaction);
    return true;
  }

  return false;
};

/**
 * Command to jump to the next block
 */
const jumpToNextBlock: StateCommand = ({ state, dispatch }) => {
  // Find the current block boundaries
  const { endLine } = findBlockBoundaries(state);

  // If we're already at the last line, can't go further down
  if (endLine >= state.doc.lines) return false;

  // Get the current cursor position to maintain horizontal position
  const selection = state.selection.main;
  const cursorPos = selection.head;
  const cursorLine = state.doc.lineAt(cursorPos);
  const cursorCol = cursorPos - cursorLine.from;

  // Look for the next block boundary by going down from the current block's end
  let targetLine = endLine + 1;

  // Skip any empty lines or braces
  while (targetLine <= state.doc.lines) {
    const line = state.doc.line(targetLine);
    const trimmed = line.text.trim();
    if (trimmed !== '' && trimmed !== '}' && trimmed !== '{') {
      break;
    }
    targetLine++;
  }

  // If we found a valid target line, move the cursor there
  if (targetLine <= state.doc.lines) {
    const line = state.doc.line(targetLine);

    // Calculate the new cursor position, maintaining the same column position
    // but clamping it to the line length to avoid going past the end
    const maxCol = line.length;
    const newCol = Math.min(cursorCol, maxCol);
    const newPos = line.from + newCol;

    const transaction = state.update({
      selection: { anchor: newPos, head: newPos },
    });
    dispatch(transaction);
    return true;
  }

  return false;
};

/**
 * Raw keymap array that can be merged with other keymaps
 */
export const livecodingKeymap: KeyBinding[] = [
  { key: 'Shift-ArrowUp', run: jumpToPreviousBlock },
  { key: 'Shift-ArrowDown', run: jumpToNextBlock },
];

/**
 * Creates an extension with the livecoding keymaps with highest precedence
 */
export function livecodingKeymapExtra(): Extension {
  return Prec.highest(keymap.of(livecodingKeymap));
}
</file>

<file path="src/renderer/src/components/codeEditor/css/commands/PropertyEvaluator.ts">
/**
 * CSS Property Evaluator Algorithm
 * -------------------------------
 * Purpose: Evaluate and manage CSS properties within a selector block, ensuring only the most recent
 * property declarations are active while commenting out older ones.
 *
 * Key Concepts:
 * 1. SELECTOR RANGE: The entire CSS selector block from { to }
 * 2. BLOCK RANGE: The current logical block of properties we're evaluating within the selector
 *
 * Algorithm Steps:
 * 1. When evaluating properties (Alt-Enter or Ctrl-Enter):
 *    a. Find the SELECTOR RANGE (from { to })
 *    b. Find the BLOCK RANGE (current group of properties)
 *    c. First uncomment everything in the BLOCK RANGE
 *    d. For each property in the BLOCK RANGE:
 *       - Find ALL occurrences of this property within the SELECTOR RANGE
 *       - If multiple occurrences found:
 *         * Keep the last occurrence in the BLOCK RANGE active
 *         * Comment out all other occurrences (both inside and outside the block but within selector)
 *
 * Example:
 * .el {
 *   transform: scale(1);     // <- Outside block, will be commented if transform exists in block
 *   color: red;             // <- Outside block, will be commented if color exists in block
 *
 *   // Current block start
 *   transform: rotate(30deg);  // <- Will be commented as it's not the last transform
 *   color: blue;              // <- Will be commented as it's not the last color
 *   transform: skew(20deg);   // <- Will stay active as it's the last transform
 *   color: green;            // <- Will stay active as it's the last color
 *   // Current block end
 *
 *   background: black;      // <- Outside block, unaffected as no background in block
 * }
 */

import { lineUncomment, toggleLineComment } from '@codemirror/commands';
import { syntaxTree } from '@codemirror/language';
import {
  type Extension,
  type StateCommand,
  EditorSelection,
  SelectionRange,
  Transaction,
} from '@codemirror/state';
import { EditorView, keymap } from '@codemirror/view';
import { flashEffect, flashLinesEffect } from '../FlashEffect';

// Cache for storing parsing results to avoid redundant operations
const parseCache = {
  lastDoc: null as string | null,
  blockLines: new Map<number, { startLine: number; endLine: number }>(),
  propertyMap: new Map<string, { line: number; commented: boolean }[]>(),
};

/**
 * Find the CSS selector block boundaries from the current cursor position
 */
function findSelectorBlockBoundaries(
  state: EditorView['state'],
): { startLine: number; endLine: number } | null {
  const selection = state.selection.main;
  const cursor = selection.head;
  const cursorLine = state.doc.lineAt(cursor);

  let startLine = cursorLine.number;
  let endLine = cursorLine.number;
  let foundOpenBrace = false;
  let foundCloseBrace = false;

  // Search upwards for opening brace
  while (startLine >= 1 && !foundOpenBrace) {
    const line = state.doc.line(startLine);
    if (line.text.includes('{')) {
      foundOpenBrace = true;
      break;
    }
    startLine--;
  }

  // Search downwards for closing brace
  while (endLine <= state.doc.lines && !foundCloseBrace) {
    const line = state.doc.line(endLine);
    if (line.text.includes('}')) {
      foundCloseBrace = true;
      break;
    }
    endLine++;
  }

  // Only return if we found both braces
  if (foundOpenBrace && foundCloseBrace) {
    return { startLine, endLine };
  }

  return null;
}

/**
 * Find all lines containing the CSS block (start from the cursor position)
 */
function findBlockLines(state: EditorView['state']): { startLine: number; endLine: number } | null {
  const selection = state.selection.main;
  const cursor = selection.head;
  const docString = state.doc.toString();
  const cursorLine = state.doc.lineAt(cursor);

  // Check cache for this cursor position
  if (parseCache.lastDoc === docString && parseCache.blockLines.has(cursorLine.number)) {
    return parseCache.blockLines.get(cursorLine.number)!;
  }

  // Find the selector block boundaries first
  const selectorBlock = findSelectorBlockBoundaries(state);
  if (!selectorBlock) return null;

  // Find the block start within the selector block (look for non-empty lines going up)
  let startLine = cursorLine.number;
  while (startLine > selectorBlock.startLine) {
    const line = state.doc.line(startLine - 1);
    const trimmed = line.text.trim();

    // Stop if we find an empty line or a line that looks like a block delimiter
    if (trimmed === '' || trimmed === '}' || trimmed === '{') {
      break;
    }

    startLine--;
  }

  // Find the block end within the selector block (look for non-empty lines going down)
  let endLine = cursorLine.number;
  while (endLine < selectorBlock.endLine) {
    const line = state.doc.line(endLine + 1);
    const trimmed = line.text.trim();

    // Stop if we find an empty line or closing brace
    if (trimmed === '' || trimmed === '}') {
      break;
    }

    endLine++;
  }

  // Update cache
  const result = { startLine, endLine };
  if (parseCache.lastDoc !== docString) {
    parseCache.lastDoc = docString;
    parseCache.blockLines.clear();
    parseCache.propertyMap.clear();
  }
  parseCache.blockLines.set(cursorLine.number, result);

  return result;
}

/**
 * Find the current line at cursor position
 */
function findCurrentLine(
  state: EditorView['state'],
): { startLine: number; endLine: number } | null {
  const selection = state.selection.main;
  const cursorLine = state.doc.lineAt(selection.head);
  return { startLine: cursorLine.number, endLine: cursorLine.number };
}

/**
 * Find all commented lines in a range - optimized with early returns
 */
function findCommentedLines(
  state: EditorView['state'],
  startLine: number,
  endLine: number,
): number[] {
  const commentedLines: number[] = [];

  for (let lineNum = startLine; lineNum <= endLine; lineNum++) {
    const line = state.doc.line(lineNum);
    if (line.text.trim().startsWith('//')) {
      commentedLines.push(lineNum);
    }
  }

  return commentedLines;
}

/**
 * Extract all distinct property names from a range of lines
 * Now with performance optimizations and caching
 */
function extractRangeProperties(
  state: EditorView['state'],
  startLine: number,
  endLine: number,
): string[] {
  const properties = new Set<string>();

  // Quick scan to avoid expensive tree operations when possible
  for (let lineNum = startLine; lineNum <= endLine; lineNum++) {
    const line = state.doc.line(lineNum);
    const trimmedText = line.text.trim();

    // Process commented lines with regex for speed
    if (trimmedText.startsWith('//')) {
      const match = trimmedText.match(/\/\/\s*([a-zA-Z-]+):/);
      if (match && match[1]) {
        properties.add(match[1].trim());
      }
      continue;
    }

    // Quick property extraction via regex for simple cases
    const quickMatch = trimmedText.match(/^([a-zA-Z-]+):/);
    if (quickMatch && quickMatch[1]) {
      properties.add(quickMatch[1].trim());
      continue;
    }

    // Use syntax tree as fallback for complex cases
    syntaxTree(state).iterate({
      from: line.from,
      to: line.to,
      enter: (node) => {
        if (node.type.name === 'PropertyName') {
          const name = state.doc.sliceString(node.from, node.to).trim();
          properties.add(name);
        }
        return false; // Only process the first property name node
      },
    });
  }

  return Array.from(properties);
}

/**
 * Find all occurrences of a property in a specific range of lines
 * Now with optimized property detection
 */
function findPropertyLinesInRange(
  state: EditorView['state'],
  propertyName: string,
  startLine: number,
  endLine: number,
): number[] {
  const lines: number[] = [];

  // Use regex-based scan for faster property detection
  for (let lineNum = startLine; lineNum <= endLine; lineNum++) {
    const line = state.doc.line(lineNum);
    const trimmedText = line.text.trim();

    // Skip commented lines quickly
    if (trimmedText.startsWith('//')) {
      continue;
    }

    // Check for property with fast regex first
    const propertyMatch = new RegExp(`^${propertyName}\\s*:`).test(trimmedText);
    if (propertyMatch) {
      lines.push(lineNum);
      continue;
    }

    // Fall back to syntax tree only for complex cases
    if (trimmedText.includes(propertyName)) {
      let found = false;
      syntaxTree(state).iterate({
        from: line.from,
        to: line.to,
        enter: (node) => {
          if (node.type.name === 'PropertyName') {
            const name = state.doc.sliceString(node.from, node.to).trim();
            if (name === propertyName) {
              found = true;
              return false;
            }
          }
          return !found;
        },
      });

      if (found) {
        lines.push(lineNum);
      }
    }
  }

  return lines;
}

/**
 * Batch comment operation to reduce individual transactions
 */
function batchCommentLines(view: EditorView, linesToComment: number[]): void {
  if (linesToComment.length === 0) return;

  // Group adjacent lines to reduce the number of selections
  const ranges: { start: number; end: number }[] = [];
  let currentRange: { start: number; end: number } | null = null;

  linesToComment
    .sort((a, b) => a - b)
    .forEach((lineNum) => {
      if (!currentRange) {
        currentRange = { start: lineNum, end: lineNum };
      } else if (lineNum === currentRange.end + 1) {
        currentRange.end = lineNum;
      } else {
        ranges.push(currentRange);
        currentRange = { start: lineNum, end: lineNum };
      }
    });

  if (currentRange) {
    ranges.push(currentRange);
  }

  // Create selections for each range
  const selections = ranges.map((range) => {
    const startLine = view.state.doc.line(range.start);
    const endLine = view.state.doc.line(range.end);
    return EditorSelection.range(startLine.from, endLine.to);
  });

  if (selections.length > 0) {
    const selection = EditorSelection.create(selections);
    const tr = view.state.update({ selection });
    view.dispatch(tr);
    toggleLineComment({ state: tr.state, dispatch: view.dispatch });
  }
}

/**
 * Core function to evaluate properties - improved implementation with batched operations
 */
function evaluatePropertiesCore(
  { state, dispatch }: { state: EditorView['state']; dispatch?: (tr: Transaction) => void },
  blockRange: { startLine: number; endLine: number },
): boolean {
  if (!dispatch) return false;

  // Store the original selection to restore it later
  const originalSelection = state.selection;

  // Clear cache if document changed
  if (parseCache.lastDoc !== state.doc.toString()) {
    parseCache.lastDoc = state.doc.toString();
    parseCache.blockLines.clear();
    parseCache.propertyMap.clear();
  }

  // Get the selector block boundaries
  const selectorBlock = findSelectorBlockBoundaries(state);
  if (!selectorBlock) return false;

  // Find any commented lines in the block range
  const commentedLines = findCommentedLines(state, blockRange.startLine, blockRange.endLine);

  // Step 1: First uncomment all commented lines in the block range
  if (commentedLines.length > 0) {
    const commentRanges = commentedLines.map((lineNum) => {
      const line = state.doc.line(lineNum);
      return EditorSelection.range(line.from, line.from);
    });

    const commentSelection = EditorSelection.create(commentRanges);
    const tr = state.update({
      selection: commentSelection,
      effects: flashLinesEffect.of(blockRange),
    });
    dispatch(tr);
    lineUncomment({ state: tr.state, dispatch });

    requestAnimationFrame(() => {
      const view = EditorView.findFromDOM(document.querySelector('.cm-editor') as HTMLElement);
      if (view) {
        applyRangeEvaluation(view, blockRange, selectorBlock);
      }
    });

    return true;
  } else {
    dispatch(
      state.update({
        effects: flashLinesEffect.of(blockRange),
      }),
    );

    const view = EditorView.findFromDOM(document.querySelector('.cm-editor') as HTMLElement);
    if (!view) return false;

    return applyRangeEvaluation(view, blockRange, selectorBlock);
  }

  function applyRangeEvaluation(
    view: EditorView,
    blockRange: { startLine: number; endLine: number },
    selectorBlock: { startLine: number; endLine: number },
  ): boolean {
    if (!view) return false;

    const updatedState = view.state;
    let anyProcessed = false;
    const linesToComment: number[] = [];

    // Extract all distinct property names from the block range
    const blockProperties = extractRangeProperties(
      updatedState,
      blockRange.startLine,
      blockRange.endLine,
    );

    blockProperties.forEach((propName) => {
      // Find ALL occurrences of this property within the selector block
      const allPropLines = findPropertyLinesInRange(
        updatedState,
        propName,
        selectorBlock.startLine,
        selectorBlock.endLine,
      );

      if (allPropLines.length > 1) {
        // Find the last occurrence within our block range
        const blockPropLines = allPropLines.filter(
          (line) => line >= blockRange.startLine && line <= blockRange.endLine,
        );

        if (blockPropLines.length > 0) {
          const lastActiveLine = blockPropLines[blockPropLines.length - 1];

          // Comment out all other occurrences of this property in the selector
          const linesToDeactivate = allPropLines.filter((line) => line !== lastActiveLine);
          linesToComment.push(...linesToDeactivate);
          anyProcessed = true;
        }
      }
    });

    // Apply all comments in one batch operation
    if (linesToComment.length > 0) {
      batchCommentLines(view, linesToComment);
    }

    // Restore the original cursor position/selection
    requestAnimationFrame(() => {
      view.dispatch({
        selection: originalSelection,
      });
    });

    return anyProcessed;
  }
}

/**
 * Command to evaluate properties in the current CSS block
 */
const evaluatePropertiesBlock: StateCommand = (params) => {
  const block = findBlockLines(params.state);
  if (!block) return false;

  return evaluatePropertiesCore(params, block);
};

/**
 * Command to comment all lines in the current CSS block
 */
const commentBlock: StateCommand = ({ state, dispatch }) => {
  const block = findBlockLines(state);
  if (!block) return false;

  // Store original selection
  const originalSelection = state.selection;

  // Check if all lines in block are commented
  let allCommented = true;
  for (let lineNum = block.startLine; lineNum <= block.endLine; lineNum++) {
    const line = state.doc.line(lineNum);
    if (!line.text.trim().startsWith('//')) {
      allCommented = false;
      break;
    }
  }

  // If all lines are commented, uncomment them
  if (allCommented) {
    const commentRanges: readonly SelectionRange[] = [];
    for (let lineNum = block.startLine; lineNum <= block.endLine; lineNum++) {
      const line = state.doc.line(lineNum);
      (commentRanges as SelectionRange[]).push(EditorSelection.range(line.from, line.from));
    }
    const selection = EditorSelection.create(commentRanges);
    const tr = state.update({ selection });
    dispatch(tr);
    lineUncomment({ state: tr.state, dispatch });

    // Restore cursor position
    requestAnimationFrame(() => {
      const view = EditorView.findFromDOM(document.querySelector('.cm-editor') as HTMLElement);
      if (view) {
        view.dispatch({
          selection: originalSelection,
        });
      }
    });
    return true;
  }
  // Otherwise comment all lines (but avoid double commenting)
  else {
    const commentRanges: readonly SelectionRange[] = [];
    for (let lineNum = block.startLine; lineNum <= block.endLine; lineNum++) {
      const line = state.doc.line(lineNum);
      if (!line.text.trim().startsWith('//')) {
        (commentRanges as SelectionRange[]).push(EditorSelection.range(line.from, line.to));
      }
    }
    if ((commentRanges as SelectionRange[]).length > 0) {
      const selection = EditorSelection.create(commentRanges);
      const tr = state.update({ selection });
      dispatch(tr);
      toggleLineComment({ state: tr.state, dispatch });

      // Restore cursor position
      requestAnimationFrame(() => {
        const view = EditorView.findFromDOM(document.querySelector('.cm-editor') as HTMLElement);
        if (view) {
          view.dispatch({
            selection: originalSelection,
          });
        }
      });
      return true;
    }
  }
  return false;
};

/**
 * Command to evaluate properties in just the current line
 * If the line is not commented, it will be commented
 * If the line is commented, it will be evaluated
 */
const evaluatePropertiesLine: StateCommand = (params) => {
  const line = findCurrentLine(params.state);
  if (!line) return false;

  // Store original selection
  const originalSelection = params.state.selection;

  // Check if current line is commented
  const currentLine = params.state.doc.line(line.startLine);
  const isCommented = currentLine.text.trim().startsWith('//');

  // If not commented, just comment it
  if (!isCommented) {
    const ranges: readonly SelectionRange[] = [
      EditorSelection.range(currentLine.from, currentLine.to),
    ];
    const selection = EditorSelection.create(ranges);
    const tr = params.state.update({ selection });
    params.dispatch?.(tr);
    toggleLineComment({ state: tr.state, dispatch: params.dispatch });

    // Restore cursor position
    requestAnimationFrame(() => {
      const view = EditorView.findFromDOM(document.querySelector('.cm-editor') as HTMLElement);
      if (view) {
        view.dispatch({
          selection: originalSelection,
        });
      }
    });
    return true;
  }

  // If commented, evaluate it
  return evaluatePropertiesCore(params, line);
};

/**
 * Creates the property evaluator extension with keyboard shortcuts
 */
export function propertyEvaluator(): Extension {
  return [
    keymap.of([
      { key: 'Alt-Enter', run: evaluatePropertiesBlock },
      { key: 'Ctrl-Enter', run: evaluatePropertiesLine },
      { key: 'Shift-Alt-Enter', run: commentBlock },
    ]),
    flashEffect(),
  ];
}
</file>

<file path="src/renderer/src/components/codeEditor/css/commands/StackModeEvaluator.ts">
import { Prec, type Extension, type StateCommand } from '@codemirror/state';
import { EditorView, keymap } from '@codemirror/view';
import { IpcEmitter } from '@electron-toolkit/typed-ipc/renderer';
import type { IpcEvents } from 'src/types/ipc';
import { flashEffect, flashLinesEffect } from '../FlashEffect';

/**
 * Find the block boundaries from the current cursor position, excluding selector lines
 */
function findBlockBoundaries(state: EditorView['state']): { startLine: number; endLine: number } {
  const selection = state.selection.main;
  const cursor = selection.head;
  const cursorLine = state.doc.lineAt(cursor);

  // Find the block start (look for non-empty lines going up)
  let startLine = cursorLine.number;
  while (startLine > 1) {
    const line = state.doc.line(startLine - 1);
    const trimmed = line.text.trim();

    // Stop if we find an empty line, brace, or selector
    if (trimmed === '' || trimmed.includes('{') || trimmed.includes('}')) {
      break;
    }

    startLine--;
  }

  // Find the block end (look for non-empty lines going down)
  let endLine = cursorLine.number;
  while (endLine < state.doc.lines) {
    const line = state.doc.line(endLine + 1);
    const trimmed = line.text.trim();

    // Stop if we find an empty line, brace, or selector
    if (trimmed === '' || trimmed.includes('{') || trimmed.includes('}')) {
      break;
    }

    endLine++;
  }

  return { startLine, endLine };
}

/**
 * Remove comment markers and clean up a line
 */
function cleanLine(line: string): string {
  // Remove // and trim
  const commentIndex = line.indexOf('//');
  if (commentIndex !== -1) {
    // Get the content after // and trim
    return line.substring(commentIndex + 2).trim();
  }
  return line.trim();
}

/**
 * Extract text content from a range of lines
 */
function extractBlockContent(
  state: EditorView['state'],
  startLine: number,
  endLine: number,
): string {
  const lines: string[] = [];
  for (let lineNum = startLine; lineNum <= endLine; lineNum++) {
    const line = state.doc.line(lineNum);
    const cleanedLine = cleanLine(line.text);
    if (cleanedLine) {
      // Only add non-empty lines
      lines.push(cleanedLine);
    }
  }
  return lines.join('\n');
}

/**
 * Command to evaluate the current block and emit its content
 */
const evaluateStackModeBlock: StateCommand = ({ state, dispatch }) => {
  // Find the block boundaries
  const block = findBlockBoundaries(state);
  if (!block) return false;

  // Extract the block content
  const content = extractBlockContent(state, block.startLine, block.endLine);
  if (!content) return false;

  // Create emitter and send the content
  const emitter = new IpcEmitter<IpcEvents>();
  emitter.send('editor:stackmode', { content });

  // Apply flash effect to show the block boundaries
  dispatch(
    state.update({
      effects: flashLinesEffect.of(block),
    }),
  );

  return true;
};

/**
 * Command to evaluate just the current line and emit its content
 */
const evaluateStackModeLine: StateCommand = ({ state, dispatch }) => {
  const selection = state.selection.main;
  const cursorLine = state.doc.lineAt(selection.head);

  // Clean the line and check if it's not empty
  const content = cleanLine(cursorLine.text);
  if (!content) return false;

  // Create emitter and send the content
  const emitter = new IpcEmitter<IpcEvents>();
  emitter.send('editor:stackmode', { content });

  // Apply flash effect to show the line
  dispatch(
    state.update({
      effects: flashLinesEffect.of({
        startLine: cursorLine.number,
        endLine: cursorLine.number,
      }),
    }),
  );

  return true;
};

/**
 * Command to clear the stack
 */
const clearStackMode: StateCommand = ({ state, dispatch }) => {
  // Create emitter and send clear command
  const emitter = new IpcEmitter<IpcEvents>();
  emitter.send('editor:stackmode', { clear: true });

  // Flash the current line to indicate the clear action
  const cursorLine = state.doc.lineAt(state.selection.main.head);
  dispatch(
    state.update({
      effects: flashLinesEffect.of({
        startLine: cursorLine.number,
        endLine: cursorLine.number,
      }),
    }),
  );

  return true;
};

/**
 * Creates the stack mode evaluator extension with keyboard shortcuts
 */
export function stackModeEvaluator(): Extension {
  return [
    Prec.highest(
      keymap.of([
        {
          key: 'Mod-Enter', // This will be Cmd on Mac and Ctrl on Windows/Linux
          run: evaluateStackModeBlock,
        },
        {
          key: 'Shift-Mod-Enter', // This will be Shift-Cmd on Mac and Shift-Ctrl on Windows/Linux
          run: evaluateStackModeLine,
        },
        {
          key: 'Alt-Mod-Enter', // This will be Opt-Cmd on Mac and Alt-Ctrl on Windows/Linux
          run: clearStackMode,
        },
      ]),
    ),
    flashEffect(),
  ];
}
</file>

<file path="src/renderer/src/components/codeEditor/css/Completions.ts">
import {
  autocompletion,
  type Completion,
  type CompletionContext,
  type CompletionResult,
} from '@codemirror/autocomplete';
import type { Extension } from '@codemirror/state';
import { EditorView } from '@codemirror/view';
import type { ControllerSetting, FontFamily } from 'src/renderer/src/types';

interface CompletionOptions {
  fontFamilies: FontFamily[];
  controllerSettings: ControllerSetting[];
  filterIds: string[];
}

// Global variables to store current options
let currentFontFamilies: FontFamily[] = [];
let currentControllerSettings: ControllerSetting[] = [];
let currentFilterIds: string[] = [];

/**
 * Updates the current completion options reactively
 */
export function updateCompletionOptions(options: CompletionOptions): void {
  currentFontFamilies = options.fontFamilies;
  currentControllerSettings = options.controllerSettings;
  currentFilterIds = options.filterIds;
}

/**
 * Creates a completion source function for CodeMirror
 * Provides completions for:
 * - font-family values
 * - MIDI controller variables ($var)
 * - SVG filter IDs for url(#filter)
 */
export function createCompletionSource(initialOptions?: CompletionOptions) {
  // Initialize with provided options if available
  if (initialOptions) {
    updateCompletionOptions(initialOptions);
  }

  return (context: CompletionContext): CompletionResult | null => {
    // Font-family completion
    const before = context.matchBefore(/font-family:\s*[^;]*/);
    if (before) {
      const word = context.matchBefore(/[^:\s;]*$/);
      if (!word && !context.explicit) return null;

      const fontOptions: Completion[] = currentFontFamilies.map((font) => ({
        label: font.name,
        type: 'class',
        boost: 1,
      }));

      return {
        from: word?.from ?? before.from,
        options: fontOptions,
        validFor: /^[^;]*$/,
      };
    }

    // MIDI variable completion
    const varWord = context.matchBefore(/\$\w*/);
    if (varWord && varWord.from !== null && !(varWord.from === varWord.to && !context.explicit)) {
      return {
        from: varWord.from,
        validFor: /^\$\w*$/,
        options: currentControllerSettings.map((setting) => ({
          label: '$' + setting.var,
          type: 'variable',
          detail: `Current value: ${setting.value}`,
          boost: 1,
        })),
      };
    }

    // SVG filter completion
    const filterWord = context.matchBefore(/url\(#[^)]*/);
    if (
      filterWord &&
      filterWord.from !== null &&
      !(filterWord.from === filterWord.to && !context.explicit)
    ) {
      const hashIndex = filterWord.text.lastIndexOf('#');

      // Find if there's a closing parenthesis and semicolon after the cursor
      const afterCursor = context.state.doc.sliceString(filterWord.to, filterWord.to + 10);
      const hasClosing = afterCursor.match(/^\s*\);/);

      return {
        from: filterWord.from + (hashIndex >= 0 ? hashIndex + 1 : filterWord.text.length),
        validFor: /^[a-zA-Z0-9-]*$/,
        options: currentFilterIds.map((id) => ({
          label: id,
          type: 'filter',
          detail: 'SVG Filter',
          info: (): HTMLElement => {
            const el = document.createElement('div');
            el.style.filter = `url(#${id})`;
            el.style.padding = '5px';
            el.textContent = 'Preview';
            return el;
          },
          apply: (view: EditorView, completion: Completion, from: number, to: number): void => {
            const insert = hasClosing ? completion.label : `${completion.label});`;
            view.dispatch({
              changes: {
                from,
                to: hasClosing ? to : to,
                insert,
              },
            });
          },
        })),
      };
    }

    // Let the default completions handle everything else
    return null;
  };
}

/**
 * Creates the completion extension for CodeMirror
 */
export function createCompletionExtension(options: CompletionOptions): Extension {
  // Initialize current options
  updateCompletionOptions(options);

  return autocompletion({
    override: [createCompletionSource()],
  });
}
</file>

<file path="src/renderer/src/components/codeEditor/css/ControllerValueSliderWidget.ts">
import { syntaxTree } from '@codemirror/language';
import { RangeSetBuilder, type Extension } from '@codemirror/state';
import {
  Decoration,
  EditorView,
  ViewPlugin,
  WidgetType,
  type DecorationSet,
  type ViewUpdate,
} from '@codemirror/view';
import type { ControllerSetting } from 'src/renderer/src/types';
import { settings as SettingsStore } from '../../../stores/settings.svelte.js';
// Global variable to store the current settings
let currentSettings: ControllerSetting[] = [];

// Widget for displaying and controlling values via dragging
class ControllerSliderWidget extends WidgetType {
  constructor(
    readonly setting: ControllerSetting,
    readonly variableName: string,
  ) {
    super();
  }

  eq(other: ControllerSliderWidget): boolean {
    return other.setting.value === this.setting.value && other.variableName === this.variableName;
  }

  toDOM(): HTMLElement {
    // Create container for the widget
    const container = document.createElement('span');
    container.className = 'cm-controller-slider';

    // Add current value indicator
    const valueDisplay = document.createElement('span');
    valueDisplay.className = 'cm-controller-value';
    valueDisplay.textContent = `${parseFloat(this.setting.value.toFixed(3))}`;

    // Assemble the widget
    container.appendChild(valueDisplay);

    return container;
  }

  // Allow handling events from within the widget
  ignoreEvent(): boolean {
    return false;
  }
}

// Find controller variables and create widget decorations
function controllerSliders(view: EditorView): DecorationSet {
  const builder = new RangeSetBuilder<Decoration>();

  // Process only visible ranges for performance
  for (const { from, to } of view.visibleRanges) {
    syntaxTree(view.state).iterate({
      from,
      to,
      enter: (node) => {
        // Check if this is a SASS variable name
        if (node.type.name === 'SassVariableName') {
          // Get the variable name without $ prefix
          const varName = view.state.doc.sliceString(node.from, node.to).substring(1);

          // Find corresponding controller setting
          const setting = currentSettings.find((s) => s.var === varName);

          if (setting) {
            // Create widget after the variable
            const deco = Decoration.widget({
              widget: new ControllerSliderWidget(setting, varName),
              side: 1, // Place widget after the variable
            });
            builder.add(node.to, node.to, deco);
          }
        }
      },
    });
  }

  return builder.finish();
}

// Function to apply value changes based on drag amount
function updateValueFromDrag(
  initialValue: number,
  dragPixels: number,
  setting: ControllerSetting,
  skipClamping: boolean = false,
): number {
  const [min, max] = setting.range;
  const range = max - min;

  // Calculate velocity-based scaling factor
  // Higher velocity = more aggressive changes
  const velocity = Math.abs(dragPixels) / 10; // Normalize pixels to a reasonable range
  const velocityScale = Math.pow(velocity + 1, 1.5) / 10; // Non-linear scaling

  // Calculate the change amount based on range and velocity
  // For zero or small initial values, we use range as base multiplier
  const baseMultiplier = Math.max(Math.abs(initialValue), range / 100);
  const changeAmount = (dragPixels * velocityScale * baseMultiplier) / 100;

  // Apply the change
  const newValue = initialValue + changeAmount;

  // Clamp to range unless skipClamping is true
  return skipClamping ? newValue : Math.max(min, Math.min(max, newValue));
}

// Simple function to update controller settings
export function updateControllerSliderValues(
  view: EditorView,
  settings: ControllerSetting[],
): void {
  currentSettings = settings;

  if (view) {
    // Force an editor update to refresh decorations
    view.dispatch({});
  }
}

// ViewPlugin to manage slider widgets and interaction
export const controllerSliderPlugin = (): Extension => {
  return ViewPlugin.fromClass(
    class {
      decorations: DecorationSet;
      dragging: boolean = false;
      draggedVarName: string | null = null;
      startX: number = 0;
      startValue: number = 0;
      draggingSpan: HTMLElement | null = null;

      constructor(readonly view: EditorView) {
        this.decorations = controllerSliders(view);
      }

      update(update: ViewUpdate): void {
        this.decorations = controllerSliders(update.view);
      }
    },
    {
      decorations: (v) => v.decorations,

      eventHandlers: {
        mousedown(e: MouseEvent, view: EditorView): boolean {
          // Check if click is on a slider widget
          const target = e.target as HTMLElement;

          if (!target.closest('.cm-controller-slider')) {
            return false;
          }

          // Find the position in the document
          const pos = view.posAtDOM(target);

          // Find the node at this position and try to get the SassVariableName
          const variableNode = syntaxTree(view.state).resolveInner(pos, -1);

          // Extract variable name
          const varName = view.state.doc
            .sliceString(variableNode.from, variableNode.to)
            .substring(1);

          // Find setting for this variable
          const setting = currentSettings.find((s) => s.var === varName);

          if (!setting) {
            return false;
          }

          // Start dragging
          this.dragging = true;
          this.draggedVarName = varName;
          this.startX = e.clientX;
          this.startValue = setting.value;
          this.draggingSpan = target;
          this.draggingSpan.classList.add('cm-controller-slider-dragging');

          // Create overlay to capture mouse events and prevent text selection
          const overlay = document.createElement('div');
          overlay.className = 'cm-drag-overlay';
          overlay.style.cssText = `
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            cursor: ew-resize;
          `;
          document.body.appendChild(overlay);

          // Set up drag event listeners
          const onMouseMove = (e: MouseEvent): void => {
            if (!this.dragging || !this.draggedVarName) return;

            // Calculate drag distance
            const deltaX = e.clientX - this.startX;

            // Find current setting
            const setting = currentSettings.find((s) => s.var === this.draggedVarName);
            if (!setting) return;

            // Check if Option (Alt) key is pressed to skip clamping
            const skipClamping = e.altKey;

            // Update value based on drag
            const newValue = updateValueFromDrag(this.startValue, deltaX, setting, skipClamping);

            // Update the value using the settings store
            SettingsStore.updateControllerValue(this.draggedVarName, newValue);

            // Force editor to redraw
            view.dispatch({});
          };

          const onMouseUp = (): void => {
            // Clean up
            this.dragging = false;
            this.draggedVarName = null;
            this.draggingSpan?.classList.remove('cm-controller-slider-dragging');

            // Remove overlay
            document.body.removeChild(overlay);

            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
          };

          // Add global event listeners
          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);

          // Prevent text selection during drag
          e.preventDefault();
          return true;
        },
      },
    },
  );
};

// Styles for the widget
const sliderWidgetTheme = EditorView.theme({
  '.cm-controller-slider': {
    display: 'inline-block',
    marginInline: '0',
    cursor: 'ew-resize',
    borderRadius: '0.1em',
    padding: '0 0.5em',
    userSelect: 'none',
    transition: 'scale 0.05s ease-in-out',
    scale: 0.8,
    backgroundColor: 'lightgray',
  },
  '.cm-controller-value': {
    fontSize: '0.9em',
    marginInline: '0',
    color: 'oklab(0.7 0.32 -0.12);',
    fontWeight: 'bold',
    userSelect: 'none',
    pointerEvents: 'none',
  },
  '.cm-controller-slider:hover': {
    backgroundColor: 'oklch(0.95 0.24 107.73 / 0.9)',
  },
  '.cm-controller-slider-dragging': {
    backgroundColor: 'oklch(0.95 0.24 107.73 / 0.9)',
  },
});

// Main extension factory function
export function controllerValueSliders(): Extension[] {
  return [controllerSliderPlugin(), sliderWidgetTheme];
}
</file>

<file path="src/renderer/src/components/codeEditor/css/ControllerValuesLineAnnotation.ts">
import { syntaxTree } from '@codemirror/language';
import { RangeSetBuilder, type Extension } from '@codemirror/state';
import {
  Decoration,
  EditorView,
  ViewPlugin,
  WidgetType,
  type DecorationSet,
  type PluginValue,
  type ViewUpdate,
} from '@codemirror/view';
import type { ControllerSetting } from 'src/renderer/src/types';

// Global variable to store the current settings
let currentSettings: ControllerSetting[] = [];

// Widget to display computed values at the end of lines
class CompiledValueWidget extends WidgetType {
  value: string;
  constructor(value) {
    super();
    this.value = value;
  }

  eq(other: CompiledValueWidget): boolean {
    return other.value === this.value;
  }

  toDOM(): HTMLElement {
    const span = document.createElement('span');
    span.className = 'cm-compiled-value';
    span.style.cssText = `
      display: inline-block;
      color: #888;
      pointer-events: none;
      user-select: none;
      white-space: pre;
      padding-left: 1ch;
    `;
    span.textContent = `→ ${this.value}`;
    return span;
  }

  ignoreEvent(): boolean {
    return true;
  }
}

// Helper to compute value from a binary expression node
function computeBinaryExpression(
  view: EditorView,
  node,
  settings: ControllerSetting[],
): string | null {
  if (!settings || !Array.isArray(settings) || settings.length === 0) return null;

  let varName: string | null = null;
  let operator: string | null = null;
  let number: number | null = null;
  let unit: string | null = null;

  // We need to find the children of this binary expression
  // We'll use syntaxTree.iterate for this specific node
  syntaxTree(view.state).iterate({
    from: node.from,
    to: node.to,
    enter: (childNode) => {
      const childName = childNode.type.name;
      const childText = view.state.doc.sliceString(childNode.from, childNode.to);
      if (childName === 'SassVariableName') {
        varName = childText.substring(1); // Remove the $ prefix
      } else if (childName === 'BinOp') {
        operator = childText.trim();
      } else if (childName === 'NumberLiteral') {
        // Extract the number and unit if present
        const match = childText.match(/^([\d.]+)([a-z%]*)$/);
        if (match) {
          number = parseFloat(match[1]);
          unit = match[2] || '';
        } else {
          number = parseFloat(childText);
          unit = '';
        }
      }

      // Continue iteration for all nodes
      return true;
    },
  });

  // Find the setting for this variable
  const setting = settings.find((s) => s.var === varName);
  if (!setting) return null;

  if (!number || !operator || !varName) {
    console.error('missing number, operator, or varName', number, operator, varName);
    return null;
  }
  // Compute the result based on the operator
  let result;
  switch (operator) {
    case '+':
      result = setting.value + number;
      break;
    case '-':
      result = setting.value - number;
      break;
    case '*':
      result = setting.value * number;
      break;
    case '/':
      result = setting.value / number;
      break;
    default:
      return null;
  }

  const roundedResult = parseFloat(result.toFixed(3));

  // Return the formatted result with the unit if present
  return unit ? `${roundedResult}${unit}` : roundedResult.toString();
}

// Theme for styling the compiled values
const compiledValueTheme = EditorView.theme({
  '.cm-compiled-value': {
    opacity: 0.7,
  },
});

export function updateControllerValues(settings: ControllerSetting[]): void {
  currentSettings = settings;
}

// Extension for displaying compiled controller values
export function compiledControllerValues(initialSettings: ControllerSetting[] = []): Extension {
  // Initialize global settings
  currentSettings = initialSettings;

  // Create the view plugin
  const plugin = ViewPlugin.fromClass(
    class implements PluginValue {
      decos: DecorationSet;
      debounceTimer: number | null = null;

      constructor(view: EditorView) {
        this.decos = this.computeDecorations(view);
      }

      // Helper to compute all decorations at once
      computeDecorations(view: EditorView): DecorationSet {
        const builder = new RangeSetBuilder<Decoration>();

        // Keep track of values per line
        const lineValues = new Map<number, string[]>();

        // Process visible lines for performance
        for (const { from, to } of view.visibleRanges) {
          syntaxTree(view.state).iterate({
            from,
            to,
            enter: (node) => {
              // Skip if not a binary expression with a SASS variable
              if (node.type.name !== 'BinaryExpression') return;

              // Find the line containing this expression
              const line = view.state.doc.lineAt(node.from);

              // Compute the value of this expression
              const value = computeBinaryExpression(view, node, currentSettings);

              if (value !== null) {
                // Add this value to the line's collection
                if (!lineValues.has(line.number)) {
                  lineValues.set(line.number, []);
                }
                lineValues.get(line.number)!.push(value);
              }
            },
          });
        }

        // Create decorations for each line
        for (const [lineNumber, values] of lineValues.entries()) {
          if (values.length > 0) {
            // Get the line
            const line = view.state.doc.line(lineNumber);
            // Join all values with commas
            const combinedValue = values.join(', ');
            const widget = new CompiledValueWidget(combinedValue);
            builder.add(
              line.to,
              line.to,
              Decoration.widget({
                widget,
                side: 1,
              }),
            );
          }
        }

        return builder.finish();
      }

      update(update: ViewUpdate): void {
        this.decos = this.computeDecorations(update.view);
      }
    },
    {
      decorations: (v) => v.decos,
    },
  );

  return [compiledValueTheme, plugin];
}
</file>

<file path="src/renderer/src/components/codeEditor/css/FlashEffect.ts">
import type { Extension } from '@codemirror/state';
import { StateEffect } from '@codemirror/state';
import type { DecorationSet, ViewUpdate } from '@codemirror/view';
import { Decoration, EditorView, ViewPlugin } from '@codemirror/view';

// Define an effect that can be dispatched to mark lines for flashing
export const flashLinesEffect = StateEffect.define<{ startLine: number; endLine: number }>();

// The styling for the flash effect
const flashTheme = EditorView.baseTheme({
  '&light .cm-flash-highlight': {
    backgroundColor: '#a6e22e33',
    animation: 'cm-flash 0.8s ease-out',
  },
  '&dark .cm-flash-highlight': {
    backgroundColor: '#a6e22e33',
    animation: 'cm-flash 0.8s ease-out',
  },
  '@keyframes cm-flash': {
    '0%': { backgroundColor: '#a6e22ecc' },
    '100%': { backgroundColor: '#a6e22e00' },
  },
});

// Decoration for highlighting the flashed lines
const flashHighlight = Decoration.line({
  attributes: { class: 'cm-flash-highlight' },
});

// Create decorations for the lines to be flashed
function createFlashDecorations(
  view: EditorView,
  startLine: number,
  endLine: number,
): DecorationSet {
  const builder = Decoration.set([]);
  let decorations = builder;

  for (let i = startLine; i <= endLine; i++) {
    const line = view.state.doc.line(i);
    decorations = decorations.update({
      add: [flashHighlight.range(line.from)],
    });
  }

  return decorations;
}

// Plugin that manages flash decorations
const flashPlugin = ViewPlugin.fromClass(
  class {
    decorations: DecorationSet = Decoration.none;

    constructor() {
      this.decorations = Decoration.none;
    }

    update(update: ViewUpdate): void {
      // Map decorations through document changes
      if (update.docChanged) {
        this.decorations = this.decorations.map(update.changes);
      }

      // Look for flash effects and apply them
      for (const tr of update.transactions) {
        for (const effect of tr.effects) {
          if (effect.is(flashLinesEffect)) {
            const { startLine, endLine } = effect.value;
            this.decorations = createFlashDecorations(update.view, startLine, endLine);

            // Clear decorations after a delay
            setTimeout(() => {
              if (update.view) {
                update.view.dispatch({
                  effects: StateEffect.appendConfig.of([]),
                });
                this.decorations = Decoration.none;
              }
            }, 800);
          }
        }
      }
    }
  },
  {
    decorations: (v) => v.decorations,
  },
);

// Export the flash effect extension
export function flashEffect(): Extension[] {
  return [flashTheme, flashPlugin];
}
</file>

<file path="src/renderer/src/components/codeEditor/css/PropertyHighlighter.ts">
import { syntaxTree } from '@codemirror/language';
import { type Extension } from '@codemirror/state';
import { Decoration, type DecorationSet, EditorView, ViewPlugin } from '@codemirror/view';

// Create a base theme for the property highlights
const propertyHighlightTheme = EditorView.baseTheme({
  '&light .cm-propertyHighlight': { backgroundColor: 'oklch(0.93 0.26 121.72 / 0.19);' },
  '&dark .cm-propertyHighlight': { backgroundColor: 'oklch(0.93 0.26 121.72 / 0.19);' },
});

// Decoration for highlighting the entire line
const propertyHighlight = Decoration.line({
  attributes: { class: 'cm-propertyHighlight' },
});

// Check if the cursor is on a line containing a PropertyName node or a commented property
function getPropertyNameAtCursor(
  view: EditorView,
): { name: string; from: number; to: number } | null {
  const { state } = view;
  const selection = state.selection.main;
  const cursor = selection.head;

  // Get the current line where the cursor is
  const cursorLine = state.doc.lineAt(cursor);

  // Try to find property name in the syntax tree for this line
  let propertyName: { name: string; from: number; to: number } | null = null;
  syntaxTree(state).iterate({
    from: cursorLine.from,
    to: cursorLine.to,
    enter: (node) => {
      // Check if the node is a PropertyName and is on the same line as the cursor
      if (node.type.name === 'PropertyName') {
        propertyName = {
          name: state.doc.sliceString(node.from, node.to).trim(),
          from: node.from,
          to: node.to,
        };
        return false; // Stop iteration once found
      }
      return true;
    },
  });

  // If not found in syntax tree, check if we're on a commented line
  if (!propertyName) {
    const lineText = cursorLine.text.trim();

    if (lineText.startsWith('//')) {
      // Try to extract property name from the comment
      // Match any text followed by a colon, capturing the text
      const match = lineText.match(/\/\/\s*([a-zA-Z-]+):/);
      if (match && match[1]) {
        const name = match[1].trim();
        // Create propertyName since we're on the line containing this property
        const nameStart = cursorLine.from + lineText.indexOf(name);
        const nameEnd = nameStart + name.length;
        propertyName = {
          name,
          from: nameStart,
          to: nameEnd,
        };
      }
    }
  }

  return propertyName;
}

// Find all occurrences of a property name in the document
function findMatchingPropertyLines(view: EditorView, propertyName: string): number[] {
  const matches: number[] = [];
  const { state } = view;

  // Get the current line number to exclude it
  const currentLine = state.doc.lineAt(state.selection.main.head);

  // Find all PropertyName nodes in the syntax tree
  syntaxTree(state).iterate({
    enter: (node) => {
      if (node.type.name === 'PropertyName') {
        const name = state.doc.sliceString(node.from, node.to).trim();
        if (name === propertyName) {
          // Get the line for this property
          const line = state.doc.lineAt(node.from);
          // Only add if it's not the current line
          if (line.number !== currentLine.number) {
            matches.push(line.from);
          }
        }
      }
    },
  });

  // Also search for property in commented lines (not found by parser)
  for (let i = 1; i <= state.doc.lines; i++) {
    // Skip the current line
    if (i === currentLine.number) continue;

    const line = state.doc.line(i);
    const lineText = line.text.trim();

    // Check if it's a comment containing our property
    if (lineText.startsWith('//') && lineText.includes(propertyName + ':')) {
      // Only add if not already added (avoid duplicates)
      if (!matches.includes(line.from)) {
        matches.push(line.from);
      }
    }
  }

  // Sort matches by line position to ensure RangeSet is created correctly
  return matches.sort((a, b) => a - b);
}

// Create the decorations for matching properties
function createPropertyDecorations(view: EditorView): DecorationSet {
  const property = getPropertyNameAtCursor(view);

  if (!property) {
    return Decoration.none;
  }

  const matchingLines = findMatchingPropertyLines(view, property.name);
  const decorations = matchingLines.map((lineStart) => propertyHighlight.range(lineStart));

  return Decoration.set(decorations);
}

// Create the plugin that manages property highlighting
const propertyHighlighterPlugin = ViewPlugin.fromClass(
  class {
    decorations: DecorationSet;

    constructor(view: EditorView) {
      this.decorations = createPropertyDecorations(view);
    }

    update(update: { view: EditorView; selectionSet: boolean }): void {
      // Only recalculate decorations when selection changes
      if (update.selectionSet) {
        this.decorations = createPropertyDecorations(update.view);
      }
    }
  },
  {
    decorations: (v) => v.decorations,
  },
);

// Export the combined extension
export function propertyHighlighter(): Extension[] {
  return [propertyHighlightTheme, propertyHighlighterPlugin];
}
</file>

<file path="src/renderer/src/components/codeEditor/AIExtension.ts">
import type { Extension } from '@codemirror/state';
import { aiExtension } from '@marimo-team/codemirror-ai';
import { aiService } from './AIService';

/**
 * Creates a CodeMirror AI extension using the AIService
 * @returns A CodeMirror extension for AI-assisted editing
 */
export function createAIExtension(): Extension {
  return aiExtension({
    // Required: Function to generate completions
    prompt: async ({ prompt, selection, codeBefore, codeAfter }) => {
      try {
        // If no selection was made, we'll use some default prompt
        const actualPrompt = prompt || 'Improve this code';

        return await aiService.generateCompletion({
          prompt: actualPrompt,
          selection,
          codeBefore,
          codeAfter,
        });
      } catch (error) {
        console.error('Error in AI extension:', error);
        return 'Error generating response. Please try again.';
      }
    },

    // Optional callbacks
    onAcceptEdit: (opts) => {
      console.log('Edit accepted', opts);
    },
    onRejectEdit: (opts) => {
      console.log('Edit rejected', opts);
    },
    onError: (error) => {
      console.error('AI extension error:', error);
    },

    // Optional configuration
    inputDebounceTime: 300, // ms
    keymaps: {
      showInput: 'Alt-a', // Trigger AI edit with Alt+A
      acceptEdit: 'Alt-y', // Accept suggestion with Alt+Y
      rejectEdit: 'Alt-n', // Reject suggestion with Alt+N
    },
  });
}
</file>

<file path="src/renderer/src/components/codeEditor/AIService.ts">
import OpenAI from 'openai';

/**
 * Interface for AI completion options
 */
interface AICompletionOptions {
  prompt: string;
  selection: string;
  codeBefore: string;
  codeAfter: string;
}

/**
 * AI service that handles code completions using OpenRouter with Gemini 2.0
 */
export class AIService {
  private client: OpenAI;

  constructor() {
    // Initialize OpenAI client with OpenRouter configuration
    this.client = new OpenAI({
      baseURL: 'https://openrouter.ai/api/v1',
      apiKey: import.meta.env.RENDERER_VITE_OPENROUTER_API_KEY || 'missing_api_key',
      dangerouslyAllowBrowser: true,
    });
  }

  /**
   * Generate code completion based on the provided options
   * @param options - The AI completion options
   * @returns A promise that resolves to the generated code
   */
  async generateCompletion(options: AICompletionOptions): Promise<string> {
    try {
      const { prompt, selection, codeBefore, codeAfter } = options;

      // Create a prompt template
      const fullPrompt = `
Given the following code context, ${prompt}

SELECTED CODE:
${selection}

CODE BEFORE SELECTION:
${codeBefore}

CODE AFTER SELECTION:
${codeAfter}

Instructions:
1. Modify ONLY the selected code
2. Maintain consistent style with surrounding code
3. Ensure the edit is complete and can be inserted directly
4. Return ONLY the replacement code, no explanations
5. Use modern programming patterns and best practices

Your task: ${prompt}`.trim();

      // Make the API call
      const completion = await this.client.chat.completions.create({
        model: 'google/gemini-2.0-flash-001',
        messages: [
          {
            role: 'user',
            content: fullPrompt,
          },
        ],
        temperature: 0.3, // Lower temperature for more focused code generation
        max_tokens: 2048, // Limit the response size
      });

      // Return the generated code
      return completion.choices[0]?.message?.content || '';
    } catch (error) {
      console.error('Error generating AI completion:', error);
      throw error;
    }
  }
}

// Export a singleton instance
export const aiService = new AIService();
</file>

<file path="src/renderer/src/components/codeEditor/CodeEditor.svelte">
<script lang="ts">
  import { closeBrackets, completionKeymap } from '@codemirror/autocomplete';
  import { defaultKeymap, toggleComment, toggleLineComment } from '@codemirror/commands';
  import { html } from '@codemirror/lang-html';
  import { sass, sassLanguage } from '@codemirror/lang-sass';
  import { syntaxTree } from '@codemirror/language';
  import { lintGutter } from '@codemirror/lint';
  import { EditorState, Prec } from '@codemirror/state';
  import { EditorView, keymap } from '@codemirror/view';
  import { basicSetup } from 'codemirror';
  import type { ControllerSetting, FontFamily } from 'src/renderer/src/types';
  import { onMount } from 'svelte';
  import { settings } from '../../stores/settings.svelte.js';
  import { createAIExtension } from './AIExtension';
  import { livecodingKeymap } from './css/commands/LivecodingKeymapExtra.js';
  import { propertyEvaluator } from './css/commands/PropertyEvaluator.js';
  import { stackModeEvaluator } from './css/commands/StackModeEvaluator.js';
  import { createCompletionSource, updateCompletionOptions } from './css/Completions.js';
  import {
    controllerValueSliders,
    updateControllerSliderValues,
  } from './css/ControllerValueSliderWidget.js';
  import {
    compiledControllerValues,
    updateControllerValues,
  } from './css/ControllerValuesLineAnnotation.js';
  import { propertyHighlighter } from './css/PropertyHighlighter.js';

  let {
    value = $bindable(''),
    language = 'css',
    controllerSettings = [],
    fontFamilys = [],
    onChange = () => {},
    pureStyle = false,
  } = $props<{
    value: string;
    language: 'css' | 'html';
    controllerSettings: ControllerSetting[];
    fontFamilys?: FontFamily[];
    onChange?: (value: string) => void;
    pureStyle?: boolean;
  }>();

  let element = $state<HTMLDivElement | undefined>();
  let view = $state<EditorView | undefined>();
  let isUpdatingFromPreview = $state(false);
  let syntaxTreeVizRepresentation = $state('');

  console.log('My fontFamilys', fontFamilys);

  $effect(() => {
    if (view && value !== view.state.doc.toString() && !isUpdatingFromPreview) {
      view.dispatch({
        changes: {
          from: 0,
          to: view.state.doc.length,
          insert: value,
        },
      });
    }
  });

  function vizualizeParserTreeLinebreaks(tree: string): string {
    // NOTE: Just a hacky way to make the parser tree more readable
    return tree
      .replace(/LineComment/g, 'LineComment\n  ')
      .replace(/"{"/g, '"{"\n  ')
      .replace(/";"/g, '";"\n  ')
      .replace(/"}"/g, '\n"}"');
  }

  $effect(() => {
    if (view) {
      syntaxTreeVizRepresentation = vizualizeParserTreeLinebreaks(
        syntaxTree(view.state).toString(),
      );
    }
  });

  // Update all extensions when settings change
  $effect(() => {
    if (view && controllerSettings && language === 'css') {
      const currentSettings = $state.snapshot(controllerSettings);
      // Update controller values extension
      updateControllerValues(currentSettings);
      updateControllerSliderValues(view, currentSettings);
      // Update completions with latest settings
      updateCompletionOptions({
        fontFamilies: fontFamilys,
        controllerSettings: currentSettings,
        filterIds: $state.snapshot(settings.filterIds),
      });
    }
  });

  onMount(() => {
    if (!element) return;

    const languageSupport = language === 'css' ? sass() : html();
    const completionOptions = {
      fontFamilies: fontFamilys,
      controllerSettings,
      filterIds: settings.filterIds,
    };

    // Base extensions that apply to both HTML and CSS
    const baseExtensions = [
      basicSetup,
      languageSupport,
      closeBrackets(),
      lintGutter(),
      createAIExtension(),
      EditorView.updateListener.of((update) => {
        if (update.docChanged) {
          value = update.state.doc.toString();
          onChange(value);
          syntaxTreeVizRepresentation = vizualizeParserTreeLinebreaks(
            syntaxTree(update.state).toString(),
          );
        }
      }),
    ];

    // CSS-specific extensions
    const cssExtensions =
      language === 'css'
        ? [
            compiledControllerValues(controllerSettings),
            controllerValueSliders(),
            propertyHighlighter(),
            propertyEvaluator(),
            stackModeEvaluator(),
            sassLanguage.data.of({
              autocomplete: createCompletionSource(completionOptions),
            }),
            keymap.of([
              ...defaultKeymap,
              ...completionKeymap,
              ...livecodingKeymap,
              { key: 'Mod-/', run: toggleLineComment },
              { key: 'Shift-Alt-a', run: toggleComment },
            ]),
            Prec.highest(keymap.of(livecodingKeymap)),
          ]
        : [
            // HTML-specific keymaps without CSS-specific extensions
            keymap.of([
              ...defaultKeymap,
              ...completionKeymap,
              { key: 'Mod-/', run: toggleLineComment },
              { key: 'Shift-Alt-a', run: toggleComment },
            ]),
          ];

    const state = EditorState.create({
      doc: value,
      extensions: [...baseExtensions, ...cssExtensions],
    });

    view = new EditorView({
      state,
      parent: element,
    });
  });
</script>

<div bind:this={element} class="editor-wrapper"></div>
{#if !pureStyle}
  <details class="parser-tree">
    <summary>Parser Tree</summary>
    <pre>{syntaxTreeVizRepresentation}</pre>
  </details>
{/if}

<style>
  .editor-wrapper {
    height: 100%;
    width: 100%;
  }

  .editor-wrapper :global(.cm-editor) {
    height: 100%;
  }

  .editor-wrapper :global(.cm-scroller) {
    overflow: auto;
  }

  .parser-tree {
    margin-top: 1rem;
    padding: 1rem;
    background: #f5f5f5;
    border-radius: 4px;
  }

  .parser-tree pre {
    margin: 0.5rem 0;
    white-space: pre;
    font-family: 'Fira Code', 'Consolas', monospace;
    font-size: 0.9em;
    overflow-x: auto;
    tab-size: 2;
    line-height: 1.4;
    padding: 0.5rem;
    background: #fff;
    border: 1px solid #ddd;
    border-radius: 3px;
  }
  :global(.ͼ2 .cm-activeLine) {
    background-color: oklch(0.96 0.25 111.39 / 0.73);
  }
</style>
</file>

<file path="src/renderer/src/components/codeEditor/codemirror-ai.d.ts">
import type { Extension } from '@codemirror/state';

// CodeMirror AI Extension Types
declare module '@marimo-team/codemirror-ai' {
  interface AIEditOptions {
    prompt: string;
    selection: string;
    codeBefore: string;
    codeAfter: string;
    result: string;
  }

  interface AIExtensionOptions {
    prompt: (options: {
      prompt: string;
      selection: string;
      codeBefore: string;
      codeAfter: string;
    }) => Promise<string>;
    onAcceptEdit?: (options: AIEditOptions) => void;
    onRejectEdit?: (options: AIEditOptions) => void;
    onError?: (error: Error) => void;
    inputDebounceTime?: number;
    keymaps?: {
      showInput: string;
      acceptEdit: string;
      rejectEdit: string;
    };
  }

  export function aiExtension(options: AIExtensionOptions): Extension;
}
</file>

<file path="src/renderer/src/components/hooks/useDebounce.svelte.ts">
export const useDebounce = (
  initialValue: unknown,
  delay: number = 250,
): {
  value: unknown;
  update: (newValue: unknown) => void;
  loading: boolean;
} => {
  let timeout = $state<ReturnType<typeof setTimeout> | null>(null);
  let value = $state<unknown>(initialValue);
  let loading = $state<boolean>(false);

  const update = (newValue: unknown): void => {
    if (timeout) clearTimeout(timeout);
    loading = true;

    timeout = setTimeout(() => {
      value = newValue;
      loading = false;
    }, delay);
  };

  return {
    get value(): unknown {
      return value;
    },
    update,
    get loading(): boolean {
      return loading;
    },
  };
};
</file>

<file path="src/renderer/src/components/midi/ControllerManager.svelte">
<script lang="ts">
  import { settings } from '@/stores/settings.svelte';
  import type { ControllerSetting } from 'src/renderer/src/types';
  import MIDIKnobPreview from './MIDIKnobPreview.svelte';

  let { controllerSettings = $bindable([]) } = $props<{
    controllerSettings: ControllerSetting[];
  }>();

  function resetValueToDefault(item: ControllerSetting) {
    settings.resetController(item.var);
  }

  let copySuccess = $state(false);
  const copyContent = async (text: string) => {
    try {
      const varNameAsSass = '$' + text;
      await navigator.clipboard.writeText(varNameAsSass);
      console.log('Content copied to clipboard');
      copySuccess = true;
      setTimeout(() => {
        copySuccess = false;
      }, 100);
    } catch (err) {
      console.error('Failed to copy: ', err);
    }
  };

  function handleSliderChange(item: ControllerSetting, event: Event) {
    const target = event.target as HTMLInputElement;
    settings.updateControllerValue(item.var, parseFloat(target.value));
  }
</script>

<hr />
<div class="controller-wrapper">
  {#each controllerSettings as item}
    <div class="item">
      <MIDIKnobPreview knobNR={item.knobNR} />
      <div>
        <p><strong>{item.name}</strong></p>
        <p>{item.range[0]}/{item.range[1]}</p>
      </div>
      <!-- <div class="key-input">
        <p>-{item.keys.down} +{item.keys.up}</p>
        <p>+-{item.step}</p>
      </div> -->
      <div
        class="var"
        role="button"
        tabindex="0"
        onclick={() => copyContent(item.var)}
        onkeydown={(e) => e.key === 'Enter' && copyContent(item.var)}
      >
        <p class:copySuccess>{item.var}</p>
      </div>
      <div
        class="value"
        role="button"
        tabindex="0"
        onclick={() => resetValueToDefault(item)}
        onkeydown={(e) => e.key === 'Enter' && resetValueToDefault(item)}
      >
        <p>{item.value}</p>
      </div>
      <div class="input-slider">
        <input
          type="range"
          id={item.name}
          name={item.name}
          min={item.range[0]}
          max={item.range[1]}
          step={item.step}
          value={item.value}
          oninput={(e) => handleSliderChange(item, e)}
        />
      </div>
    </div>
  {/each}
</div>

<style>
  .copySuccess {
    color: #00ff00;
  }
  .controller-wrapper {
    display: grid;
    grid-template-columns: 1fr 1fr;
    font-size: 0.8em;
    grid-gap: 0.8rem;
  }
  .item {
    display: grid;
    grid-template-columns: min-content 1.5fr 1fr 1fr 1.5fr;
    border: 1px solid #000;
    padding: 0.5rem;
    border-radius: 1em;
  }
  .item input {
    width: 100%;
  }
  .item p {
    margin: 0;
  }
  .var,
  .value {
    text-align: right;
    font-size: 1.2em;
    font-weight: bold;
  }
  .var:hover {
    color: #00ff00;
  }
  .value {
    cursor: pointer;
  }
  .value:hover {
    color: #00ff00;
  }
  .input-slider {
    grid-column: 1 / span 5;
    height: 1.2em;
  }
</style>
</file>

<file path="src/renderer/src/components/midi/MIDIKnobPreview.svelte">
<script lang="ts">
  let { knobNR = 0 } = $props<{
    knobNR?: number;
  }>();

  const maxKnobs: number = 16;
  const midiKnobs: number[] = [...Array(maxKnobs).keys()];
</script>

<div class="midiController">
  {#each midiKnobs as knob}
    {#if knob === knobNR}
      <div class="knob active"></div>
    {:else}
      <div class="knob"></div>
    {/if}
  {/each}
</div>

<style>
  .midiController {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    width: 3em;
    height: 3em;
    padding: 2px;
  }
  .knob {
    width: 0.5em;
    height: 0.5em;
    border-radius: 50%;
    background-color: lightgray;
    margin: 0 1px;
  }
  .knob.active {
    background-color: #00ff00;
  }
</style>
</file>

<file path="src/renderer/src/components/pageElement/BlockImg.svelte">
<script lang="ts">
  interface Props {
    content?: string;
    isCurrent?: boolean;
  }

  let { content = 'Hello World', isCurrent = false }: Props = $props();
  let isCurrentClass = $derived(isCurrent ? 'current' : '');
</script>

<img src={content} alt="img" class={isCurrentClass} />

<style>
  img {
    width: 100px;
    height: 100px;
    display: inline-block;
  }
  .current {
    color: blue;
  }
</style>
</file>

<file path="src/renderer/src/components/pageElement/BlockTxt.svelte">
<script lang="ts">
  import type { BlockTxtSettings, ControllerSetting } from 'src/renderer/src/types';
  import { checkPosition } from './checkPosition.js';

  let {
    content = 'Hello World',
    isCurrent = false,
    settings = {
      editorCss: '',
      controllerSettings: [],
    },
    onOverflow = () => {},
  } = $props<{
    content?: string;
    isCurrent?: boolean;
    settings?: BlockTxtSettings;
    onOverflow?: () => void;
  }>();

  function transformSassToCSS(
    str: string | undefined,
    controllerSettings: ControllerSetting[],
  ): string {
    if (!str) return '';
    const staticString = $state.snapshot(str);
    const staticControllerSettings = $state.snapshot(controllerSettings);

    // Extract only the .el{} element
    const elMatch = staticString.match(/\.el\s*{([^}]*)}/);
    if (!elMatch || !elMatch[1]) return '';

    // Get just the content inside .el{}
    let cssContent = elMatch[1];

    // Remove comments in one pass
    cssContent = cssContent.replace(/\/\/[^\n]*|\/\*[\s\S]*?\*\//g, '');

    // If no controller settings, return cleaned CSS
    if (!controllerSettings?.length) return cssContent.trim();

    // Create a variable lookup map for faster access
    const varMap = new Map();
    for (const setting of staticControllerSettings) {
      varMap.set(setting.var, setting.value);
    }

    // Process variable replacements efficiently
    // Handle both $var and $var * value patterns in a single pass
    const result = cssContent.replace(
      /\$([a-zA-Z0-9_]+)(?:\s*\*\s*([\d.]+)([a-z%]+)?)?/g,
      (match, varName, multiplier, unit) => {
        const value = varMap.get(varName);
        if (value === undefined) return match; // Keep original if var not found

        if (multiplier !== undefined) {
          const calculated = value * parseFloat(multiplier);
          return unit ? calculated + unit : calculated.toString();
        }

        return value.toString();
      },
    );

    return result.trim();
  }

  let isCurrentClass = $derived(isCurrent ? 'current' : '');
  let compiledStyle = $derived(
    transformSassToCSS(settings?.editorCss, settings?.controllerSettings),
  );
</script>

<span
  class={isCurrentClass}
  style={compiledStyle}
  use:checkPosition={!isCurrent
    ? {
        registerOverflow: () => onOverflow(),
      }
    : null}
>
  {content}&nbsp;<wbr />
</span>

<style>
  span {
    print-color-adjust: exact;
    -webkit-print-color-adjust: exact;
    /* filter: blur(0);
    -webkit-filter: blur(0); */
  }
  .current {
    color: blue;
  }
</style>
</file>

<file path="src/renderer/src/components/pageElement/checkPosition.ts">
interface CheckPositionParams {
  registerOverflow: (element: HTMLElement) => void;
}

export function checkPosition(
  element: HTMLElement,
  params: CheckPositionParams | null,
): { destroy: () => void } {
  // If no params provided or explicitly set to null, don't do any checking
  if (!params) return { destroy: (): void => {} };

  const { registerOverflow } = params;
  const page = element.closest('page');
  if (!page) return { destroy: (): void => {} };

  const pageRect = page.getBoundingClientRect();
  const elementRect = element.getBoundingClientRect();

  const distanceToBottom = pageRect.height - (elementRect.bottom - pageRect.top);
  const percentToBottom = (distanceToBottom / pageRect.height) * 100;

  // Only log if we're actually checking position
  console.log('Element space check:', {
    content: element.textContent?.trim(),
    distanceToBottom,
    percentToBottom,
  });

  if (distanceToBottom < 0 || percentToBottom < 5) {
    registerOverflow(element);
  }

  return {
    destroy(): void {
      // Cleanup if needed
    },
  };
}
</file>

<file path="src/renderer/src/components/status/PrintStatus.svelte">
<script lang="ts">
  import { quintOut } from 'svelte/easing';
  import { slide } from 'svelte/transition';

  interface Status {
    emoji: string;
    text?: string;
  }

  let { printId, status } = $props<{
    printId: string;
    status: Status;
  }>();
</script>

<div class="status-item" title="{printId} – {status.text || 'Print status update'}">
  {#key status.emoji}
    <span transition:slide={{ duration: 600, axis: 'x', easing: quintOut }} class="emoji"
      >{status.emoji}</span
    >
  {/key}
  <!-- {#if status.text}-->
  <!--hover to show printId-->
  <!-- <button class="text" 
        aria-label={`Print status: ${printId} ${status.text}`}
        on:click={() => {
            console.log(`${printId} ${status.text}`);
        }}>
    </button> -->
  <!-- {/if} -->
</div>

<style>
  .status-item {
    display: flex;
    align-items: center;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.8);
    font-size: 1.2em;
    transition: all 0.2s ease;
  }

  .emoji {
    font-size: 1.2em;
  }
</style>
</file>

<file path="src/renderer/src/components/status/PrintStatusBar.svelte">
<script lang="ts">
  import { IpcListener } from '@electron-toolkit/typed-ipc/renderer';
  import type { PrintStatusMessage } from 'src/types';
  import type { IpcRendererEvent } from 'src/types/ipc';
  import { onMount } from 'svelte';
  import { fly } from 'svelte/transition';
  import PrintStatus from './PrintStatus.svelte';
  const ipc = new IpcListener<IpcRendererEvent>();

  interface StatusEmojis {
    LOCAL_REQUEST: string;
    QUEUED: string;
    PRINT_START: string;
    PRINT_COMPLETE: {
      SUCCESS: string;
      ERROR: string;
    };
    PDF_SAVE: {
      SUCCESS: string;
    };
    PRINT_ERROR: string;
  }

  interface StatusEntry {
    emoji: string;
    text: string;
  }

  let printStatuses = $state(new Map<string, StatusEntry>());
  let successPrintCount = $state(0);
  let successPdfCount = $state(0);
  let failureCount = $state(0);

  // Status emoji mapping based on action and status
  const STATUS_EMOJIS: StatusEmojis = {
    LOCAL_REQUEST: '🥚',
    QUEUED: '🐣',
    PRINT_START: '🎀',
    PRINT_COMPLETE: {
      SUCCESS: '🖨️',
      ERROR: '🥵',
    },
    PDF_SAVE: {
      SUCCESS: '💦',
    },
    PRINT_ERROR: '🥵',
  };

  function updateStatus(printId: string, newStatus: string, text = ''): void {
    if (!printId) {
      console.warn('⚠️ Attempted to update status without printId');
      return;
    }
    printStatuses.set(printId, { emoji: newStatus, text });
    printStatuses = new Map(printStatuses); // Create new Map to trigger reactivity
  }

  function scheduleSuccessCleanup(id: string, type: 'print' | 'PDF'): void {
    setTimeout(() => {
      printStatuses.delete(id);
      printStatuses = new Map(printStatuses); // Create new Map to trigger reactivity
      console.log(`🧹 Cleaned up successful ${type} status: ${id}`);
    }, 20000);
  }

  export function addPrintRequest(): number {
    const printId = Date.now();
    updateStatus(printId.toString(), STATUS_EMOJIS.LOCAL_REQUEST, 'Print request created');
    console.log(`🥚 Added new print request with ID: ${printId}`);
    return printId;
  }

  // Add print request handler
  onMount(() => {
    ipc.on(
      'print-queued',
      (_, { success, error, printId }: { success: boolean; error?: string; printId: string }) => {
        if (success) {
          updateStatus(printId, '🐣', 'Print job queued successfully');
        } else {
          updateStatus(printId, '🥵', `Print queue error: ${error}`);
        }
      },
    );

    ipc.on('print-status', (_event, message: PrintStatusMessage) => {
      const { id, action, status, ...details } = message;
      let emoji = '❓';
      let text = 'Unknown status';

      switch (action) {
        case 'PRINT_START':
          emoji = '🎀';
          text = details.message || 'Starting print...';
          break;
        case 'PRINT_COMPLETE':
          emoji = status === 'SUCCESS' ? '🖨️' : '🥵';
          text = details.message || (status === 'SUCCESS' ? 'Print complete' : 'Print failed');
          if (status === 'SUCCESS') {
            successPrintCount++;
            scheduleSuccessCleanup(id, 'print');
          } else {
            failureCount++;
          }
          break;
        case 'PDF_SAVE':
          emoji = status === 'SUCCESS' ? '💦' : '🥵';
          text = details.message || (status === 'SUCCESS' ? 'PDF saved' : 'PDF save failed');
          if (status === 'SUCCESS') {
            successPdfCount++;
            scheduleSuccessCleanup(id, 'PDF');
          } else {
            failureCount++;
          }
          break;
        case 'PRINT_ERROR':
          emoji = '🥵';
          text = details.message || 'Print error occurred';
          failureCount++;
          break;
      }

      updateStatus(id, emoji, text);
    });

    return () => {
      console.log('🛑 PrintStatusBar cleanup stopped');
    };
  });
</script>

<div class="status-bar">
  <div class="counter" title="Success Prints / Success PDFs / Failures">
    <span class="success">{successPrintCount}</span>/<span class="success">{successPdfCount}</span
    >/<span class="failure">{failureCount}</span>
  </div>
  {#each Array.from(printStatuses) as [printId, status] (printId)}
    <div transition:fly={{ y: 100, duration: 1000 }}>
      <PrintStatus {printId} {status} />
    </div>
  {/each}
</div>

<style>
  .status-bar {
    position: fixed;
    bottom: 20px;
    right: 20px;
    display: flex;
    flex-direction: row-reverse;
    gap: 8px;
    padding: 8px;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 20px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    max-width: 80vw;
    overflow-x: auto;
    backdrop-filter: blur(4px);
    overflow-y: hidden;
  }
  @media print {
    .status-bar {
      display: none;
    }
  }

  .counter {
    display: flex;
    align-items: center;
    padding: 4px 8px;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 12px;
    font-size: 0.9em;
    font-family: monospace;
    font-weight: bold;
  }

  .success {
    color: #22c55e;
  }

  .failure {
    color: #ef4444;
  }

  /* Hide scrollbar but keep functionality */
  .status-bar::-webkit-scrollbar {
    display: none;
  }
  .status-bar {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }
</style>
</file>

<file path="src/renderer/src/components/status/TransInfoMessagesLog.svelte">
<script lang="ts">
  let messages = $state<string[]>([]);
  import { IpcListener } from '@electron-toolkit/typed-ipc/renderer';
  import type { IpcRendererEvent } from 'src/types/ipc';

  const ipc = new IpcListener<IpcRendererEvent>();

  // Listen for transcription status updates
  ipc.on('whisper-ccp-stream:status', (_, value: string) => {
    messages = [value, ...messages];
  });
</script>

{#each messages as item}
  <p>{item}</p>
{/each}

<style>
  p {
    margin: 0.25em 0;
    font-family: inherit;
  }
</style>
</file>

<file path="src/renderer/src/components/ui/PreviewButton.svelte">
<script lang="ts">
  interface Props {
    isPrintPreview?: boolean;
    onClick?: () => void;
  }

  let { isPrintPreview = false, onClick = () => {} }: Props = $props();
</script>

<button
  class="preview-button"
  class:active={isPrintPreview}
  onclick={onClick}
  disabled={isPrintPreview}
>
  {isPrintPreview ? '🖨️ Preview Mode (5s)' : '👁️ Preview Print'}
</button>

<style>
  .preview-button {
    padding: 6px 12px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: white;
    cursor: pointer;
    font-family: monospace;
    font-size: 0.9em;
    transition: all 0.2s ease;
  }

  .preview-button:hover:not(:disabled) {
    background: #f0f0f0;
  }

  .preview-button:disabled {
    opacity: 0.7;
    cursor: not-allowed;
  }

  .preview-button.active {
    background: #e6f3ff;
    border-color: #007bff;
    color: #007bff;
  }
</style>
</file>

<file path="src/renderer/src/components/ui/SnapshotManager.svelte">
<script lang="ts">
  import { settings } from '@/stores/settings.svelte.js';
  import { snapshots } from '@/stores/snapshots.svelte.js';
  import BlockTxt from '@components/pageElement/BlockTxt.svelte';

  // Original settings for revert functionality
  let originalSettings = $state<{
    editorCss: string;
    svgFilters: string;
    controllerValues: Record<string, number>;
  } | null>(null);

  // Snapshot management functions
  async function saveSnapshot(): Promise<void> {
    // Use a default name instead of prompt
    const name = `Snapshot ${new Date().toLocaleString()}`;

    try {
      const result = await snapshots.saveSnapshot(name);
      if (result) {
        console.log('Snapshot saved successfully:', result);
      } else {
        console.error('Failed to save snapshot');
      }
    } catch (error) {
      console.error('Error saving snapshot:', error);
    }
  }

  async function applySnapshot(id: string): Promise<void> {
    // Store original settings before applying snapshot if not already stored
    if (!originalSettings) {
      originalSettings = {
        editorCss: settings.editorCss,
        svgFilters: settings.svgFilters,
        controllerValues: { ...settings.controllerValues },
      };
    }

    try {
      const success = await snapshots.applySnapshot(id);
      if (success) {
        console.log('Snapshot applied successfully');
      } else {
        console.error('Failed to apply snapshot');
      }
    } catch (error) {
      console.error('Error applying snapshot:', error);
    }
  }

  async function mergeSnapshot(id: string): Promise<void> {
    // Store original settings before merging snapshot if not already stored
    if (!originalSettings) {
      originalSettings = {
        editorCss: settings.editorCss,
        svgFilters: settings.svgFilters,
        controllerValues: { ...settings.controllerValues },
      };
    }

    try {
      const success = await snapshots.mergeSnapshot(id);
      if (success) {
        console.log('Snapshot merged successfully');
      } else {
        console.error('Failed to merge snapshot');
      }
    } catch (error) {
      console.error('Error merging snapshot:', error);
    }
  }

  async function deleteSnapshot(id: string): Promise<void> {
    // Remove confirm dialog
    try {
      const success = await snapshots.deleteSnapshot(id);
      if (success) {
        console.log('Snapshot deleted successfully');
      } else {
        console.error('Failed to delete snapshot');
      }
    } catch (error) {
      console.error('Error deleting snapshot:', error);
    }
  }

  function revertToOriginal(): void {
    if (!originalSettings) return;

    settings.editorCss = originalSettings.editorCss;
    settings.svgFilters = originalSettings.svgFilters;

    // Restore controller values
    Object.entries(originalSettings.controllerValues).forEach(([varName, value]) => {
      settings.updateControllerValue(varName, value);
    });

    // Clear original settings after applying
    originalSettings = null;

    console.log('Reverted to original settings');
  }
</script>

<div class="snapshotHeader">
  <BlockTxt content="Snapshots" {settings} />
</div>

<div class="snapshotControls">
  <button onclick={() => saveSnapshot()}>Save Snapshot</button>
  {#if originalSettings}
    <button onclick={() => revertToOriginal()}>Revert Changes</button>
  {/if}
</div>

<div class="snapshotsContainer">
  {#each snapshots.snapshots as snapshot (snapshot.id)}
    {@const staticControllerSettings = settings.controllerSettings.map((ctrl) => ({
      ...ctrl,
      value:
        snapshot.controllerValues[ctrl.var] !== undefined
          ? snapshot.controllerValues[ctrl.var]
          : ctrl.value,
    }))}

    <div class="snapshotItem">
      <button class="snapshotPreview" onclick={() => mergeSnapshot(snapshot.id)}>
        <BlockTxt
          content={snapshot.name}
          settings={{
            editorCss: snapshot.editorCss,
            svgFilters: snapshot.svgFilters,
            controllerSettings: $state.snapshot(staticControllerSettings as unknown),
          }}
        />
      </button>
      <div class="snapshotActions">
        <button onclick={() => applySnapshot(snapshot.id)}>↑</button>
        <button onclick={() => deleteSnapshot(snapshot.id)}>×</button>
      </div>
    </div>
  {/each}
</div>

<style>
  .snapshotHeader {
    position: relative;
    margin-bottom: 1rem;
  }

  .snapshotControls {
    display: flex;
    align-items: baseline;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  .snapshotsContainer {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    margin-top: 1rem;
    max-height: 300px;
    overflow-y: auto;
  }

  .snapshotItem {
    display: flex;
    align-items: flex-start;
    border: 1px solid #ddd;
    padding: 0.5rem;
    position: relative;
  }

  .snapshotItem:hover {
    border-color: #888;
  }

  .snapshotPreview {
    flex: 1;
    cursor: pointer;
    padding: 0.25rem;
    background: none;
    border: none;
    text-align: left;
    width: 100%;
    margin: 0;
    white-space: nowrap;
    overflow: hidden;
    contain: strict;
    height: 3em;
  }

  .snapshotPreview:hover {
    background-color: rgba(0, 0, 0, 0.05);
  }

  .snapshotActions {
    position: absolute;
    top: 0.25rem;
    right: 0.25rem;
  }

  .snapshotActions button {
    background: none;
    border: none;
    font-size: 1.2rem;
    cursor: pointer;
    color: #888;
    margin-left: 0.25rem;
  }

  .snapshotActions button:first-child {
    color: #4a90e2;
  }

  .snapshotActions button:first-child:hover {
    color: #2a70c2;
  }

  .snapshotActions button:last-child:hover {
    color: #f00;
  }
</style>
</file>

<file path="src/renderer/src/stores/commands.svelte.ts">
import { IpcEmitter } from '@electron-toolkit/typed-ipc/renderer';
import type { CommandResponse, IpcEvents } from 'src/types/ipc';

const emitter = new IpcEmitter<IpcEvents>();

class CommandStore {
  async execute<T>(command: string, payload?: unknown): Promise<CommandResponse<T>> {
    try {
      const response = (await emitter.invoke(
        'command:execute',
        command,
        payload,
      )) as CommandResponse<T>;
      return response;
    } catch (error) {
      console.error(`Error executing command ${command}:`, error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  }
}

export const commands = new CommandStore();
</file>

<file path="src/renderer/src/stores/remoteSettings.svelte.ts">
import { IpcEmitter, IpcListener } from '@electron-toolkit/typed-ipc/renderer';
import type { IpcEvents, IpcRendererEvent } from 'src/types/ipc';
import { untrack } from 'svelte';
import { settings } from './settings.svelte';

const emitter = new IpcEmitter<IpcEvents>();

class RemoteSettingsStore {
  editorCss = $state('');
  svgFilters = $state('');
  controllerSettings = settings.controllerSettings;
  controllerValues = settings.controllerValues;
  #initialized = $state(false);

  constructor() {
    // Initialize with settings from main settings store
    this.init();
  }

  /**
   * Update the .el{} block in editorCss with current stack content
   */
  #updateEditorCssWithStack(newContent?: string): void {
    // Find or create the .el{} block
    const elBlockRegex = /\.el\s*{([^}]*)}/;
    const match = this.editorCss.match(elBlockRegex);

    if (match) {
      // Get existing content
      const existingLines = match[1]
        .split('\n')
        .map((line) => line.trim())
        .filter((line) => line.length > 0);

      // Add new content if provided
      if (newContent) {
        const newLines = newContent.split('\n').map((line) => line.trim());
        existingLines.push(...newLines);
      }

      // Keep only the last 20 lines
      const finalLines = existingLines.slice(-10);

      // Create the new block with proper indentation
      const blockContent = finalLines.map((line) => '  ' + line).join('\n');
      const newElBlock = `.el {\n${blockContent}${blockContent ? '\n' : ''}}`;

      // Replace existing block
      this.editorCss = this.editorCss.replace(elBlockRegex, newElBlock);
    } else {
      // Create new block if it doesn't exist
      const lines = newContent ? newContent.split('\n').map((line) => line.trim()) : [];
      const blockContent = lines.map((line) => '  ' + line).join('\n');
      const newElBlock = `.el {\n${blockContent}${blockContent ? '\n' : ''}}`;
      this.editorCss = this.editorCss + '\n\n' + newElBlock;
    }

    // Sync changes
    this.sendToRemote();
  }

  init(): void {
    if (this.#initialized) return;

    // Set up listeners for settings sync from editor windows
    const ipc = new IpcListener<IpcRendererEvent>();

    // Listen for stack mode commands
    ipc.on('editor:stackmode', (_, data) => {
      if (data.clear) {
        this.#updateEditorCssWithStack(''); // Clear by passing empty content
      } else if (data.content) {
        this.#updateEditorCssWithStack(data.content);
      }
    });

    ipc.on('settings-sync', (_, syncedSettings) => {
      console.log(
        'Received remote settings update:',
        syncedSettings.editorCss,
        syncedSettings.svgFilters?.length,
      );
      if (syncedSettings.editorCss !== undefined) {
        this.editorCss = syncedSettings.editorCss;
      }
      if (syncedSettings.svgFilters !== undefined) {
        this.svgFilters = syncedSettings.svgFilters;
      }
    });

    // Initialize with current settings
    this.editorCss = $state.snapshot(settings.editorCss);
    this.svgFilters = $state.snapshot(settings.svgFilters);

    $effect.root(() => {
      // Watch for changes in the main settings store
      $effect(() => {
        console.log('settings.editorCss', settings.editorCss);
        if (settings.editorCss && settings.svgFilters) {
          untrack(() => {
            // Only update if our values are different from the main settings
            // to avoid circular updates
            if (this.editorCss !== settings.editorCss) {
              this.editorCss = settings.editorCss;
            }
            if (this.svgFilters !== settings.svgFilters) {
              this.svgFilters = settings.svgFilters;
            }
          });
        }
      });
    });

    this.#initialized = true;
  }

  // Send our settings to other windows through the main process
  sendToRemote(): void {
    emitter.send('editor:settings-updated', {
      editorCss: this.editorCss,
      svgFilters: this.svgFilters,
    });
  }

  // Update remote settings with new values and optionally send to remote
  update(values: { editorCss?: string; svgFilters?: string }, sendToRemote = true): void {
    if (values.editorCss !== undefined) {
      this.editorCss = values.editorCss;
    }
    if (values.svgFilters !== undefined) {
      this.svgFilters = values.svgFilters;
    }
    if (sendToRemote) {
      this.sendToRemote();
    }
  }
}

// Create and export a single instance of the remote settings store
export const remoteSettings = new RemoteSettingsStore();
</file>

<file path="src/renderer/src/stores/settings.svelte.ts">
import { IpcEmitter } from '@electron-toolkit/typed-ipc/renderer';
import { mapRange } from '@utils/math.js';
import type { ControllerSetting, Settings } from 'src/renderer/src/types';
import type { IpcEvents } from 'src/types/ipc';
import { WebMidi } from 'webmidi';
import defaultInlineStyle from '../assets/input-defaults/editorCss.js';
import inputJson from '../assets/input-defaults/input.json';
import defaultSvgFilters from '../assets/input-defaults/svgFilters.js';

const emitter = new IpcEmitter<IpcEvents>();

// Default settings structure
const defaultSettings: Settings = {
  controllerSettings: [],
  editorCss: '',
  svgFilters: '',
};

class SettingsStore {
  #controllerSettings = $state<ControllerSetting[]>([]);
  #editorCss = $state('');
  #svgFilters = $state('');
  #initialized = $state(false);
  #codeEditorContentSaved = $state(true);
  #lastSavedInlineStyle = $state('');
  #lastSavedSvgFilters = $state('');

  constructor() {
    // Initialize with default values
    this.#controllerSettings = defaultSettings.controllerSettings;
    this.#editorCss = defaultSettings.editorCss;
    this.#svgFilters = defaultSettings.svgFilters;
  }

  set controllerSettings(value: ControllerSetting[]) {
    this.#controllerSettings = value;
  }

  get controllerSettings(): ControllerSetting[] {
    return this.#controllerSettings;
  }

  set editorCss(value: string) {
    this.#editorCss = value;
  }

  get editorCss(): string {
    return this.#editorCss;
  }

  set svgFilters(value: string) {
    this.#svgFilters = value;
  }

  get svgFilters(): string {
    return this.#svgFilters;
  }
  // Debounce helper
  #debounce<Args extends unknown[], R>(
    func: (...args: Args) => R,
    delay: number,
  ): (...args: Args) => void {
    let timeout: NodeJS.Timeout;
    return (...args: Args): void => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), delay);
    };
  }

  // Check if content is valid (not empty/whitespace and hasn't lost too much content)
  #isValidContent(newContent: string, savedContent: string): boolean {
    // Check if content is empty or just whitespace
    if (!newContent.trim()) {
      console.warn('Prevented saving empty content');
      return false;
    }

    // If saved content exists, check if too much has been deleted
    if (savedContent) {
      const contentLengthReduction = 1 - newContent.length / savedContent.length;

      // If more than 50% is deleted and it's more than 5 lines
      const newLines = newContent.split('\n').length;
      const savedLines = savedContent.split('\n').length;
      const linesReduction = savedLines - newLines;

      if (contentLengthReduction > 0.5 && linesReduction > 5) {
        console.warn('Prevented saving drastically reduced content');
        return false;
      }
    }

    return true;
  }

  // Debounced save function
  #debouncedSave = this.#debounce(async (): Promise<void> => {
    console.log('Saving settings to electron store');

    // Check inline style content
    const isInlineStyleValid = this.#isValidContent(this.#editorCss, this.#lastSavedInlineStyle);
    // Check SVG filters content
    const isSvgFiltersValid = this.#isValidContent(this.#svgFilters, this.#lastSavedSvgFilters);

    if (!isInlineStyleValid || !isSvgFiltersValid) {
      console.warn('Safety check prevented saving potentially deleted content');
      // Reload from last saved state
      this.reloadFromSaved();
      return;
    }

    // Save valid content
    await emitter.invoke('setStoreValue', 'editorCss', this.#editorCss);
    await emitter.invoke('setStoreValue', 'svgFilters', this.#svgFilters);

    // Notify other windows about the settings change
    emitter.send('editor:settings-updated', {
      editorCss: this.#editorCss,
      svgFilters: this.#svgFilters,
    });

    // Update last saved values
    this.#lastSavedInlineStyle = this.#editorCss;
    this.#lastSavedSvgFilters = this.#svgFilters;
    this.#codeEditorContentSaved = true;
  }, 1000);

  // Reload content from last saved state
  reloadFromSaved(): void {
    if (this.#lastSavedInlineStyle) {
      this.#editorCss = this.#lastSavedInlineStyle;
    }

    if (this.#lastSavedSvgFilters) {
      this.#svgFilters = this.#lastSavedSvgFilters;
    }

    this.#codeEditorContentSaved = true;
    console.log('Reloaded content from last saved state');
  }

  // Update a specific controller value
  updateControllerValue(varName: string, newValue: number): void {
    const controller = this.#controllerSettings.find((c) => c.var === varName);
    if (controller) {
      // Round to 2 decimal places and remove trailing zeros
      controller.value = parseFloat(newValue.toFixed(2));
    }
  }

  // Reset a controller to its default value
  resetController(varName: string): void {
    const controller = this.#controllerSettings.find((c) => c.var === varName);
    if (controller) {
      controller.value = controller.default;
    }
  }

  // Load settings from electron store and defaults
  async init(): Promise<void> {
    if (this.#initialized) return;

    try {
      // Load from electron store
      const savedInlineStyle = (await emitter.invoke('getStoreValue', 'editorCss')) as string;
      const savedSvgFilters = (await emitter.invoke('getStoreValue', 'svgFilters')) as string;

      // Initialize with defaults and saved values
      const controllers = (inputJson.controllers || []) as ControllerSetting[];

      this.#controllerSettings = controllers;
      this.#editorCss = savedInlineStyle || defaultInlineStyle;
      this.#svgFilters = savedSvgFilters || defaultSvgFilters;

      // Store the initial saved values
      this.#lastSavedInlineStyle = this.#editorCss;
      this.#lastSavedSvgFilters = this.#svgFilters;

      console.log('init settings', this);

      this.#initialized = true;
      console.log('Settings loaded successfully');
    } catch (err) {
      console.error('Error loading settings:', err);
    }
  }

  setupControllers(webMidi: typeof WebMidi): void {
    if (!webMidi || !webMidi.inputs.length) {
      console.warn('No MIDI device detected.');
      return;
    }

    const mySynth = webMidi.inputs[0];

    this.#controllerSettings.forEach((controller) => {
      console.log('controller', controller);
      window.setTimeout(() => {
        console.log('set synth');
        console.log('mySynth', mySynth);

        mySynth.channels[1].addListener('controlchange', (e) => {
          if (e.controller.number === controller.knobNR && typeof e.value === 'number') {
            const value = mapRange(e.value, 0, 1, controller.range[0], controller.range[1]);
            this.updateControllerValue(controller.var, Number.parseFloat(value.toFixed(2)));
          }
        });
      }, 5000);
    });
  }

  // Mark content as unsaved and trigger save
  markUnsaved(): void {
    this.#codeEditorContentSaved = false;
    this.#debouncedSave();
  }

  // Computed values
  get codeEditorContentSaved(): boolean {
    return this.#codeEditorContentSaved;
  }

  get controllerValues(): Record<string, number> {
    return Object.fromEntries(this.#controllerSettings.map((ctrl) => [ctrl.var, ctrl.value]));
  }

  get filterIds(): string[] {
    return extractFilterIds(this.#svgFilters);
  }
}

// Helper function to extract filter IDs from SVG code
function extractFilterIds(svgCode: string): string[] {
  const parser = new DOMParser();
  const doc = parser.parseFromString(svgCode, 'text/html');
  const filters = doc.querySelectorAll('filter[id]');
  return Array.from(filters).map((filter) => filter.id);
}

// Create and export a single instance of the settings store
export const settings = new SettingsStore();
</file>

<file path="src/renderer/src/stores/snapshots.svelte.ts">
import { IpcEmitter } from '@electron-toolkit/typed-ipc/renderer';
import type { SettingsSnapshot, SettingsSnapshotListResponse } from 'src/types';
import type { IpcEvents } from 'src/types/ipc';
import { v4 as uuidv4 } from 'uuid';
import { mergeInlineStyles } from '../utils/styleMerger';
import { remoteSettings } from './remoteSettings.svelte';
import { settings } from './settings.svelte';

const emitter = new IpcEmitter<IpcEvents>();

class SnapshotsStore {
  #snapshots = $state<SettingsSnapshot[]>([]);
  #snapshotsLoaded = $state(false);

  constructor() {
    // Load snapshots initially
    this.loadSnapshots().catch(console.error);
  }

  // Create and save a new settings snapshot
  async saveSnapshot(name: string = ''): Promise<SettingsSnapshot | null> {
    try {
      // Create a snapshot of the current settings
      const snapshot: SettingsSnapshot = {
        id: uuidv4(),
        name: name || `Snapshot ${new Date().toLocaleString()}`,
        timestamp: Date.now(),
        editorCss: remoteSettings.editorCss,
        svgFilters: remoteSettings.svgFilters,
        controllerValues: remoteSettings.controllerValues,
      };

      // Save the snapshot via IPC
      const savedSnapshot = await emitter.invoke('save-settings-snapshot', snapshot);
      console.log('Saved settings snapshot:', savedSnapshot);

      // Update local snapshots list
      await this.loadSnapshots();

      return savedSnapshot;
    } catch (error) {
      console.error('Error saving settings snapshot:', error);
      return null;
    }
  }

  // Load all available snapshots
  async loadSnapshots(): Promise<SettingsSnapshot[]> {
    try {
      const response = (await emitter.invoke(
        'get-settings-snapshots',
      )) as SettingsSnapshotListResponse;

      if (response.success) {
        this.#snapshots = response.snapshots;
        this.#snapshotsLoaded = true;
      } else {
        console.error('Error loading snapshots:', response.error);
      }

      return this.#snapshots;
    } catch (error) {
      console.error('Error loading snapshots:', error);
      return [];
    }
  }

  // Apply a settings snapshot
  async applySnapshot(id: string): Promise<boolean> {
    try {
      const snapshot = await emitter.invoke('load-settings-snapshot', id);

      if (!snapshot) {
        console.error(`Snapshot with ID ${id} not found`);
        return false;
      }

      // Apply the snapshot values to the settings store
      settings.editorCss = snapshot.editorCss;
      settings.svgFilters = snapshot.svgFilters;

      // Update controller values
      if (snapshot.controllerValues) {
        Object.entries(snapshot.controllerValues).forEach(([varName, value]) => {
          settings.updateControllerValue(varName, value);
        });
      }

      // Trigger save in the settings store
      settings.markUnsaved();

      console.log(`Applied snapshot: ${snapshot.name}`);
      return true;
    } catch (error) {
      console.error(`Error applying snapshot with ID ${id}:`, error);
      return false;
    }
  }

  // Merge a settings snapshot with current settings
  async mergeSnapshot(id: string): Promise<boolean> {
    try {
      const snapshot = await emitter.invoke('load-settings-snapshot', id);

      if (!snapshot) {
        console.error(`Snapshot with ID ${id} not found`);
        return false;
      }

      // Merge the inline style
      if (snapshot.editorCss && settings.editorCss) {
        settings.editorCss = mergeInlineStyles(settings.editorCss, snapshot.editorCss);
      }

      // Update controller values
      if (snapshot.controllerValues) {
        Object.entries(snapshot.controllerValues).forEach(([varName, value]) => {
          settings.updateControllerValue(varName, value);
        });
      }

      // Keep current SVG filters
      // settings.svgFilters remains unchanged

      // Trigger save in the settings store
      settings.markUnsaved();

      console.log(`Merged snapshot: ${snapshot.name}`);
      return true;
    } catch (error) {
      console.error(`Error merging snapshot with ID ${id}:`, error);
      return false;
    }
  }

  // Delete a settings snapshot
  async deleteSnapshot(id: string): Promise<boolean> {
    try {
      const success = await emitter.invoke('delete-settings-snapshot', id);

      if (success) {
        // Refresh snapshots list
        await this.loadSnapshots();
        console.log(`Deleted snapshot with ID ${id}`);
      } else {
        console.error(`Failed to delete snapshot with ID ${id}`);
      }

      return success;
    } catch (error) {
      console.error(`Error deleting snapshot with ID ${id}:`, error);
      return false;
    }
  }

  // Get all snapshots
  get snapshots(): SettingsSnapshot[] {
    if (!this.#snapshotsLoaded) {
      this.loadSnapshots().catch(console.error);
    }
    return this.#snapshots;
  }
}

// Create and export a single instance of the snapshots store
export const snapshots = new SnapshotsStore();
</file>

<file path="src/renderer/src/utils/logger.ts">
import log from 'electron-log/renderer';

// Configure console transport
log.transports.console.level = 'debug';
log.transports.console.format = '{h}:{i}:{s}.{ms} › {scope} {text}';

// Create scoped loggers for different parts of the application
export const uiLogger = log.scope('ui');
export const printLogger = log.scope('print');
export const settingsLogger = log.scope('settings');
export const midiLogger = log.scope('midi');

// Export the base logger as default
export default log;
</file>

<file path="src/renderer/src/utils/math.ts">
export const mapRange = (value: number, x1: number, y1: number, x2: number, y2: number): number =>
  ((value - x1) * (y2 - x2)) / (y1 - x1) + x2;

export const clamp = (value: number, min: number, max: number): number =>
  Math.max(min, Math.min(value, max));

export const round = (value: number, precision: number = 2): number =>
  Math.round(value * Math.pow(10, precision)) / Math.pow(10, precision);

export const getRandom = (min: number, max: number): number => Math.random() * (max - min) + min;
</file>

<file path="src/renderer/src/utils/styleMerger.ts">
/**
 * Utility functions for merging CSS styles between snapshots and current settings
 */

/**
 * Merge two inline styles together, treating lines as either active or deactivated (commented)
 */
export function mergeInlineStyles(currentStyle: string, snapshotStyle: string): string {
  // Extract .el {} block from both styles
  const currentElBlock = extractElBlock(currentStyle);
  const snapshotElBlock = extractElBlock(snapshotStyle);

  if (!currentElBlock || !snapshotElBlock) {
    return currentStyle; // Can't merge, return current style
  }

  // Get all active lines from snapshot
  const snapshotActiveLines = extractActiveLines(snapshotElBlock);

  // Get all lines (active and commented) from current style
  const currentLines = extractAllLines(currentElBlock);

  // Perform the merge (activate/deactivate lines)
  const mergedBlock = performLineMerge(currentLines, snapshotActiveLines);

  // Replace the current .el block with the merged one
  return currentStyle.replace(/\.el\s*\{[^}]*\}/s, mergedBlock);
}

/**
 * Extract the .el {} block from a CSS string
 */
function extractElBlock(style: string): string | null {
  const elMatch = style.match(/\.el\s*\{([^}]*)\}/s);
  return elMatch ? elMatch[0] : null;
}

/**
 * Extract active (non-commented) lines from a style block
 */
function extractActiveLines(styleBlock: string): string[] {
  // Remove the .el { } wrapper to get just the content
  const content = styleBlock.replace(/\.el\s*\{\s*([\s\S]*?)\s*\}/s, '$1');

  // Split into lines and filter out commented or empty lines
  return content
    .split('\n')
    .map((line) => line.trim())
    .filter((line) => line && !line.trim().startsWith('//'));
}

/**
 * Extract all lines from a style block, preserving original formatting
 */
function extractAllLines(styleBlock: string): string[] {
  // Remove the .el { } wrapper to get just the content
  const content = styleBlock.replace(/\.el\s*\{\s*([\s\S]*?)\s*\}/s, '$1');

  // Split into lines preserving original formatting
  return content.split('\n');
}

/**
 * Perform line-by-line merge by activating/deactivating lines
 */
function performLineMerge(currentLines: string[], snapshotActiveLines: string[]): string {
  // Start with the opening bracket
  let result = '.el {';

  // Track which snapshot lines have been processed
  const processedSnapshotLines = new Set<string>();

  // Determine the standard indentation to use
  const indentation = '  '; // Always use 2 spaces as requested

  // Process each current line
  for (const line of currentLines) {
    const trimmedLine = line.trim();

    // Skip empty lines
    if (!trimmedLine) {
      result += '\n';
      continue;
    }

    // Check if this is a commented line
    const isCommented = trimmedLine.startsWith('//');

    // Get the actual content (removing comment prefix if needed)
    const contentLine = isCommented ? trimmedLine.replace(/^\s*\/\/\s*/, '').trim() : trimmedLine;

    // Check if this line exists in the snapshot's active lines
    const lineExistsInSnapshot = snapshotActiveLines.some((snapshotLine) => {
      const matches = snapshotLine.trim() === contentLine;
      if (matches) {
        processedSnapshotLines.add(snapshotLine.trim());
      }
      return matches;
    });

    if (lineExistsInSnapshot) {
      // This line should be active - ensure it's uncommented
      if (isCommented) {
        // Uncomment the line and apply consistent indentation
        result += `\n${indentation}${contentLine}`;
      } else {
        // Already active, but ensure consistent indentation
        result += `\n${indentation}${trimmedLine}`;
      }
    } else {
      // This line should be deactivated - ensure it's commented
      if (isCommented) {
        // Already commented, but ensure consistent indentation
        result += `\n${indentation}${trimmedLine}`;
      } else {
        // Comment the line and apply consistent indentation
        result += `\n${indentation}// ${contentLine}`;
      }
    }
  }

  // Add any snapshot lines that weren't in the current style
  const unprocessedSnapshotLines = snapshotActiveLines.filter(
    (line) => !processedSnapshotLines.has(line.trim()),
  );

  if (unprocessedSnapshotLines.length > 0) {
    // Add a blank line before adding new lines if the last line isn't already empty
    if (currentLines.length > 0 && currentLines[currentLines.length - 1].trim() !== '') {
      result += '\n';
    }

    // Add each new line with proper indentation
    for (const line of unprocessedSnapshotLines) {
      result += `\n${indentation}${line.trim()}`;
    }
  }

  // Add the closing bracket
  result += '\n}';

  return result;
}
</file>

<file path="src/renderer/src/utils/utils.ts">
export const debounce = <F extends (...args: Parameters<F>) => ReturnType<F>>(
  func: F,
  waitFor: number,
): ((...args: Parameters<F>) => void) => {
  let timeout: NodeJS.Timeout;

  const debounced = (...args: Parameters<F>): void => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), waitFor);
  };

  return debounced;
};
</file>

<file path="src/renderer/src/window/debug/components/LogContainer.svelte">
<script lang="ts">
  import { IpcEmitter } from '@electron-toolkit/typed-ipc/renderer';
  import type { IpcEvents } from 'src/types/ipc.ts';
  const emitter = new IpcEmitter<IpcEvents>();

  import { onMount, untrack } from 'svelte';

  interface LogEntry {
    timestamp: string;
    message: string;
    pdfUrl?: string | null;
    spanCount?: number | null;
    type: string;
    printId?: string | null;
    isOldSession?: boolean;
  }

  let { logs = $bindable<LogEntry[]>([]) } = $props();
  let logContainer = $state<HTMLDivElement>();
  let shouldAutoScroll = $state(true);
  const MAX_STORED_LOGS = 200;

  let previousLogs = $state<LogEntry[]>([]);

  // Load saved logs on mount
  onMount(async () => {
    try {
      const savedLogs = ((await emitter.invoke('getStoreValue', 'printLogs')) || []) as LogEntry[];
      if (savedLogs.length > 0) {
        // Add session divider only on first load
        const sessionDivider: LogEntry = {
          timestamp: new Date().toLocaleTimeString(),
          message: '---------------- Previous Session ----------------',
          type: 'divider',
          isOldSession: true,
        };

        // Mark all saved logs as old session
        const oldLogs = savedLogs.map((log: LogEntry) => ({
          ...log,
          isOldSession: true,
        }));

        previousLogs = [...oldLogs, sessionDivider];

        // Initial scroll to bottom
        requestAnimationFrame(() => {
          scrollToBottom();
        });
      }
    } catch (error) {
      console.error('Failed to load saved logs:', error);
    }
  });

  // Check if user is near bottom
  function isNearBottom() {
    if (!logContainer) return true;
    const threshold = 150;
    const position = logContainer.scrollHeight - logContainer.scrollTop - logContainer.clientHeight;
    return position <= threshold;
  }

  // Handle scroll events
  function handleScroll() {
    shouldAutoScroll = isNearBottom();
  }

  // Toggle auto-scroll
  function toggleAutoScroll() {
    shouldAutoScroll = !shouldAutoScroll;
    if (shouldAutoScroll) {
      requestAnimationFrame(() => {
        scrollToBottom();
      });
    }
  }

  function scrollToBottom() {
    if (!logContainer) return;
    logContainer.scrollTop = logContainer.scrollHeight;
  }

  // Clear logs function
  async function clearLogs() {
    if (confirm('Are you sure you want to clear all logs?')) {
      await emitter.invoke('setStoreValue', 'printLogs', []);
      logs = [];
      previousLogs = [];
    }
  }
  let mergedLogs = $derived([...previousLogs, ...logs]);

  let logsToStore = $derived(mergedLogs.slice(-MAX_STORED_LOGS).map((log: LogEntry) => log));

  $inspect(logsToStore);

  $effect(() => {
    if (logsToStore.length) {
      untrack(() => {
        console.log('Saving logs:', $state.snapshot(logsToStore[logsToStore.length - 1]));
        emitter
          .invoke('setStoreValue', 'printLogs', $state.snapshot(logsToStore))
          .catch((error) => console.error('Failed to save logs:', error));
      });
    }
  });

  $effect(() => {
    if (shouldAutoScroll && logsToStore) {
      requestAnimationFrame(() => {
        scrollToBottom();
      });
    }
  });

  // Save logs when they change
  // $effect(() => {
  //   if (mergedLogs.length !== previousLogsLength) {
  //     console.log('previousLogsLength', previousLogsLength)
  //     // Save all logs including dividers, but ensure they're serializable
  //     const logsToStore = mergedLogs.slice(-MAX_STORED_LOGS).map((log: LogEntry) => (log))
  //     console.log('Saving logs:', logsToStore)
  //     emitter
  //       .invoke('setStoreValue', 'printLogs', logsToStore)
  //       .catch((error) => console.error('Failed to save logs:', error))
  //     // previousLogsLength = mergedLogs.length

  //     // If auto-scroll is enabled, scroll after the DOM updates
  //     if (shouldAutoScroll) {
  //       requestAnimationFrame(() => {
  //         scrollToBottom()
  //       })
  //     }
  //   }
  // })
</script>

<div class="print-log">
  <div class="log-header">
    <div class="log-title">Print Job Log</div>
    <div class="log-controls">
      <button
        class="auto-scroll-toggle"
        class:active={shouldAutoScroll}
        onclick={toggleAutoScroll}
        title={shouldAutoScroll ? 'Disable auto-scroll' : 'Enable auto-scroll'}
      >
        {shouldAutoScroll ? '📌 Auto-scroll on' : '🔓 Auto-scroll off'}
      </button>
      <button class="clear-logs-btn" onclick={clearLogs} title="Clear all logs"> 🗑️ </button>
      <div class="log-count">{mergedLogs.length} entries ({logs.length} fresh)</div>
    </div>
  </div>
  <div class="log-container" bind:this={logContainer} onscroll={handleScroll}>
    {#each mergedLogs as log}
      <div
        class="log-entry"
        class:server-message={log.type === 'server'}
        class:old-session={log.isOldSession}
        class:session-divider={log.type === 'divider'}
      >
        <span class="log-timestamp">[{log.timestamp}]</span>
        <span class="log-message">{log.message}</span>
        <div class="log-details">
          {#if log.spanCount !== null && log.spanCount !== undefined}
            <span class="span-count" class:span-count-zero={log.spanCount === 0}
              >{log.spanCount} spans</span
            >
          {/if}
          {#if log.pdfUrl}
            <a href={log.pdfUrl} target="_blank" class="pdf-link">View PDF</a>
          {/if}
          {#if log.type === 'server'}
            <span class="server-badge">Server</span>
          {/if}
        </div>
      </div>
    {/each}
  </div>
</div>

<style>
  .print-log {
    flex: 0 0 auto;
    background: #f0f0f0;
    border-top: 1px solid #ccc;
    font-family: monospace;
    padding: 8px;
  }

  .log-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 4px;
  }

  .log-controls {
    display: flex;
    align-items: baseline;
    gap: 8px;
  }

  .auto-scroll-toggle {
    font-size: 0.8em;
    padding: 2px 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 4px;
    color: #666;
  }

  .auto-scroll-toggle:hover {
    background: #f8f8f8;
  }

  .auto-scroll-toggle.active {
    background: #e6f3ff;
    border-color: #007bff;
    color: #007bff;
  }

  .log-title {
    font-weight: bold;
  }

  .log-count {
    font-size: 0.9em;
    color: #666;
  }

  .log-container {
    height: calc(5 * (1.2em + 4px + 4px)); /* 5 entries: line-height + padding */
    overflow-y: auto;
    background: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 8px;
  }

  .log-entry {
    font-size: 0.9em;
    padding: 2px 0;
    margin: 2px 0;
    color: #444;
    display: flex;
    align-items: center;
    gap: 8px;
    min-height: 1.2em;
  }

  .server-message {
    background: #7afd94;
  }

  .log-timestamp {
    color: #666;
    flex-shrink: 0;
  }

  .log-message {
    flex: 1;
  }

  .log-details {
    display: flex;
    gap: 8px;
    align-items: center;
    flex-shrink: 0;
  }

  .span-count {
    color: #666;
    font-size: 0.8em;
    background: #f0f0f0;
    padding: 2px 6px;
    border-radius: 3px;
  }

  .span-count-zero {
    color: #ffffff;
    background: #ff0000;
  }

  .server-badge {
    color: #ffffff;
    font-size: 0.8em;
    background: #09dd13;
    padding: 2px 6px;
    border-radius: 3px;
    font-weight: 500;
  }

  .pdf-link {
    background: #007bff;
    color: white;
    text-decoration: none;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 0.8em;
    flex-shrink: 0;
  }

  .pdf-link:hover {
    background: #0056b3;
  }

  .clear-logs-btn {
    font-size: 0.8em;
    padding: 2px 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: white;
    cursor: pointer;
    color: #666;
  }

  .clear-logs-btn:hover {
    background: #fff0f0;
    border-color: #ff4444;
    color: #ff4444;
  }

  .old-session {
    opacity: 0.7;
    background: #fafafa;
  }

  .old-session:hover {
    opacity: 1;
  }

  .session-divider {
    text-align: center;
    color: #999;
    font-style: italic;
    background: #f5f5f5;
    border-top: 1px dashed #ddd;
    border-bottom: 1px dashed #ddd;
  }

  .session-divider .log-timestamp {
    opacity: 0.5;
  }

  .session-divider .log-message {
    text-align: center;
  }
  @media print {
    .log-container {
      display: none;
    }
  }
</style>
</file>

<file path="src/renderer/src/window/debug/components/PageSimulator.svelte">
<script lang="ts">
  import { untrack } from 'svelte';

  interface Props {
    // Props
    scale?: number;
    showControls?: boolean;
    centered?: boolean;
    children?: import('svelte').Snippet;
  }

  let { scale = $bindable(1), showControls = true, centered = true, children }: Props = $props();

  // State
  let page: HTMLElement | undefined = $state();
  let pageContext: HTMLElement | undefined = $state();

  function fittedToPage() {
    if (!page || !pageContext) return scale;
    const pageRect = page.getBoundingClientRect();
    const contextRect = pageContext.getBoundingClientRect();
    const optimalScale = Math.min(
      (contextRect.width * 0.95) / (pageRect.width / scale),
      (contextRect.height * 0.95) / (pageRect.height / scale),
    );
    return optimalScale;
  }

  function adjustedScale(delta: number) {
    return Math.max(0.1, Math.min(2, scale + delta));
  }

  $effect(() => {
    untrack(() => {
      scale = fittedToPage();
    });
  });
</script>

{#if showControls}
  <div id="scale-controls">
    <button onclick={() => (scale = adjustedScale(-0.1))}>-</button>
    <span>{scale.toFixed(2)}</span>
    <button onclick={() => (scale = adjustedScale(0.1))}>+</button>
    <button onclick={() => (scale = fittedToPage())}>0</button>
  </div>
{/if}

<div class="page-context" class:centered bind:this={pageContext}>
  <div class="page-container" style:transform={`scale(${scale})`}>
    <page size="A3" bind:this={page}>
      <div class="content-context">
        {@render children?.()}
      </div>
    </page>
  </div>
</div>

<style>
  #scale-controls {
    position: absolute;
    top: 10px;
    right: 20px;
    z-index: 1001;
    display: flex;
    gap: 10px;
    align-items: center;
  }

  #scale-controls button {
    padding: 5px 10px;
    cursor: pointer;
  }

  /* Page styles */
  .page-context {
    text-align: left;
    font-size: 2em;
    font-weight: 100;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    position: relative;
    overflow: hidden;
  }

  .page-context.centered {
    position: fixed;
    height: 100%;
    z-index: 500;
  }

  .content-context {
    height: 100%;
  }

  page {
    background: white;
    display: block;
    box-shadow: 0 0 0.5cm rgba(0, 0, 0, 0.5);
  }

  page[size='A3'] {
    width: calc(297.3mm * 0.86);
    height: calc(420.2mm * 0.895);
    padding: 2cm;
    background: url('../../../assets/scan.png'); /* this path is corrrect!!! */
    background-size: 100% 100%;
    transform-origin: center;
    transition: all 0.3s ease;
  }

  /* Container for maintaining aspect ratio and centering */
  .page-container {
    transform-origin: center;
    transition: all 0.3s ease;
  }

  @media print {
    :global(body, html) {
      print-color-adjust: exact;
      -webkit-print-color-adjust: exact;
    }
    page[size='A3'] {
      background: white;
    }

    #scale-controls {
      display: none;
    }
    .page-context {
      transform: none !important;
    }
    .page-container {
      transform: none !important;
    }
  }
</style>
</file>

<file path="src/renderer/src/window/debug/components/PageSimulatorWrapper.svelte">
<script lang="ts">
  import Page from './PageSimulator.svelte';

  interface Props {
    // Props
    scale?: number;
    showControls?: boolean;
    position?: string; // 'right', 'center', 'left'
    children?: import('svelte').Snippet;
  }

  let { scale = 1, showControls = true, position = 'right', children }: Props = $props();
</script>

<div
  class="page-wrapper"
  class:right={position === 'right'}
  class:center={position === 'center'}
  class:left={position === 'left'}
>
  <Page {scale} {showControls} centered={false}>
    {@render children?.()}
  </Page>
</div>

<style>
  .page-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    overflow: hidden;
  }

  .page-wrapper.right {
    justify-content: flex-end;
    padding-right: 2rem;
  }

  .page-wrapper.center {
    justify-content: center;
  }

  .page-wrapper.left {
    justify-content: flex-start;
    padding-left: 2rem;
  }

  @media print {
    .page-wrapper {
      transform: none !important;
    }
  }
</style>
</file>

<file path="src/renderer/src/window/debug/App.svelte">
<script lang="ts">
  import { IpcEmitter, IpcListener } from '@electron-toolkit/typed-ipc/renderer';
  import { onMount } from 'svelte';
  import { printJobSchema, type PrintJob } from '../../../../types';
  import type { IpcEvents, IpcRendererEvent } from '../../../../types/ipc';
  import LogContainer from './components/LogContainer.svelte';
  import PageWrapper from './components/PageSimulatorWrapper.svelte';
  const ipc = new IpcListener<IpcRendererEvent>();
  const emitter = new IpcEmitter<IpcEvents>();

  let status = $state('Waiting for print job...');
  let lastJobTime = $state('Never');
  let stylesLoaded = $state('No');
  // eslint-disable-next-line no-undef
  let children = $state<NodeListOf<HTMLSpanElement> | null>(null);
  let printLogs = $state<
    Array<{
      timestamp: string;
      message: string;
      pdfUrl: string | null;
      spanCount: number | null;
      type: string;
      printId: string | null;
    }>
  >([]);
  let currentPrintId = $state<string | null>(null);
  let isPrintPreview = $state(false);
  let currentAttempt = $state(0);
  let maxRetries = $state(0);
  let queueLength = $state(0);
  let isQueueProcessing = $state(false);
  let printStartTime = $state<number | null>(null);

  function addLogEntry(
    message: string,
    pdfUrl: string | null = null,
    spanCount: number | null = null,
    type = 'client',
  ) {
    const timestamp = new Date().toLocaleTimeString();
    printLogs = [
      ...printLogs,
      {
        timestamp,
        message,
        pdfUrl,
        spanCount,
        type,
        printId: currentPrintId,
      },
    ];
  }

  function updateLogEntryWithPdfUrl(printId: string, pdfUrl: string) {
    printLogs = printLogs.map((log) => {
      if (log.printId === printId) {
        return { ...log, pdfUrl };
      }
      return log;
    });
  }

  async function executePrint(printJobUnsave: PrintJob) {
    const printJob = printJobSchema.parse(printJobUnsave);
    currentPrintId = printJob.printId;
    console.log('Executing print with ID:', currentPrintId);

    try {
      await emitter.invoke('PrintWindow:ReadyToBePrinted', printJob);
      // Status updates will come from main process
    } catch (error) {
      console.error('Print error:', error);
      const message = error instanceof Error ? error.message : String(error);
      addLogEntry(`Error: ${message}`, null, null, 'error');
      throw error instanceof Error ? error : new Error(String(error)); // Propagate error for queue handling
    }
  }

  onMount(() => {
    console.log('Print window initialized');

    // Listen for print status updates
    ipc.on('print-status', (_event, data) => {
      console.log('Print status update:', data);

      if (!data?.id) {
        console.warn('Received print status without ID:', data);
        return;
      }

      const { action, status: printStatus, message, id } = data;
      currentPrintId = id;

      // Update status based on action and status
      switch (action) {
        case 'PRINT_START':
          status = message || 'Starting print job...';
          lastJobTime = new Date().toLocaleTimeString();
          addLogEntry(message || 'Print job started', null, null, 'server');
          break;

        case 'PRINT_COMPLETE':
          if (printStatus === 'SUCCESS') {
            const duration = printStartTime
              ? ((Date.now() - printStartTime) / 1000).toFixed(2)
              : '0.00';
            status = message || `Print completed successfully (${duration}s)`;
            addLogEntry(
              message || `Print completed successfully (${duration}s)`,
              null,
              children?.length,
              'server',
            );
          } else {
            status = message || 'Print failed';
            addLogEntry(message || 'Print failed', null, null, 'server');
          }
          printStartTime = null;
          break;

        case 'PDF_SAVE':
          if (printStatus === 'SUCCESS' && message) {
            const pdfPath = message.match(/to (.+)$/)?.[1];
            if (pdfPath) {
              updateLogEntryWithPdfUrl(id, `file://${pdfPath}`);
              addLogEntry('PDF saved successfully', `file://${pdfPath}`, null, 'server');
            }
          }
          break;

        case 'PRINT_ERROR':
          status = message || 'Print error occurred';
          addLogEntry(message || 'Print error occurred', null, null, 'server');
          printStartTime = null;
          break;
      }
    });

    // Also add back server message handling for transcription status
    ipc.on('whisper-ccp-stream:status', (_event, message) => {
      if (typeof message === 'string') {
        addLogEntry(message, null, null, 'server');
      }
    });

    // Handle print job setup
    ipc.on('PrintWindow:printJob', async (_event, printJobUnsave: PrintJob) => {
      try {
        const newPrintJob = printJobSchema.parse(printJobUnsave);
        console.log('onPrintJob', newPrintJob);

        // Set current print ID first
        currentPrintId = newPrintJob.printId;
        currentAttempt = newPrintJob.attempt;
        maxRetries = newPrintJob.maxRetries;
        printStartTime = Date.now();

        console.log(
          `Processing print job with ID: ${currentPrintId} (Attempt ${currentAttempt}/${maxRetries})`,
        );

        status = `Processing print job (Attempt ${currentAttempt}/${maxRetries})`;
        lastJobTime = new Date().toLocaleTimeString();
        addLogEntry(`Processing print job (Attempt ${currentAttempt}/${maxRetries})`);

        // Get the container
        const container = document.getElementById('print-container');
        if (!container) {
          throw new Error('Print container not found');
        }
        container.innerHTML = '';

        // Inject any dynamic styles
        if (newPrintJob.pageContent.editorCss) {
          const styleSheet = document.createElement('style');
          styleSheet.textContent = newPrintJob.pageContent.editorCss;
          document.head.appendChild(styleSheet);

          // Update styles loaded status
          const styleLength = newPrintJob.pageContent.editorCss.length;
          stylesLoaded = `Yes - ${styleLength} - ${new Date().toLocaleTimeString()}`;
          addLogEntry(`Styles loaded (${styleLength} bytes)`);
        } else {
          console.warn('No inline styles provided for print job');
          stylesLoaded = 'No';
        }

        // Inject SVG filters if they exist
        if (newPrintJob.pageContent.svgFilters) {
          console.log('Adding SVG filters');
          // reuse the same div for all svg filters
          let filtersDiv = document.getElementById('svg-filters');
          if (!filtersDiv) {
            filtersDiv = document.createElement('div');
            filtersDiv.id = 'svg-filters';
            filtersDiv.style.display = 'none';
            document.body.appendChild(filtersDiv);
          }
          filtersDiv.innerHTML = newPrintJob.pageContent.svgFilters;
        } else {
          console.warn('No SVG filters provided for print job');
        }

        // Set the content
        container.innerHTML = newPrintJob.pageContent.html;
        children = container.querySelectorAll('span');

        if (children && children.length === 0) {
          console.warn('Print content contains no text spans');
        }

        status = 'Content loaded, waiting 5 seconds before print...';
        addLogEntry('Content loaded, preparing to print', null, children?.length ?? 0);

        // Wait for debug/inspection
        await new Promise((resolve) => setTimeout(resolve, 5000));

        status = 'Printing...';
        addLogEntry('Starting print process...', null, children?.length ?? 0);

        console.log('Executing print with settings:', newPrintJob);

        // Execute print with the same settings including printId
        await executePrint(newPrintJob);
      } catch (error) {
        console.error('Print job error:', error);
        const message = error instanceof Error ? error.message : String(error);
        status = `Error: ${message}`;
        addLogEntry(`Error: ${message}`, null, null, 'error');
      }
    });

    // Handle queue status updates
    ipc.on('queue-status', (_event, status) => {
      console.log('Queue status update:', status);
      queueLength = status.queueLength || 0;
      isQueueProcessing = status.isProcessing;

      // Update status message based on queue state
      if (queueLength > 0) {
        if (isQueueProcessing) {
          addLogEntry(`Processing print queue (${queueLength} remaining)`, null, null, 'server');
        } else {
          addLogEntry(`Print queue paused (${queueLength} pending)`, null, null, 'server');
        }
      } else if (queueLength === 0 && !isQueueProcessing) {
        addLogEntry('Print queue empty', null, null, 'server');
      }
    });
  });
</script>

<div id="print-window-wrapper">
  <div id="print-debug-info" class="debug-info">
    <div class="debug-row">
      <div class="debug-info-left">
        <div>Status: <span>{status}</span></div>
        <div>Last job received: <span>{lastJobTime}</span></div>
        <div>Styles loaded: <span>{stylesLoaded}</span></div>
        <div>Spans: <span>{children ? children.length : 0}</span></div>
        {#if currentAttempt > 1}
          <div class="retry-info">Retry attempt: <span>{currentAttempt}/{maxRetries}</span></div>
        {/if}
        <div class="queue-info">
          Queue: <span class:active={isQueueProcessing}
            >{queueLength} job{queueLength !== 1 ? 's' : ''}
            {isQueueProcessing ? '(processing)' : ''}</span
          >
        </div>
      </div>
      <div class="debug-controls"></div>
    </div>
  </div>

  <div class="page-container-wrapper">
    <PageWrapper showControls={!isPrintPreview} position="center">
      <div id="print-container"></div>
    </PageWrapper>
  </div>

  <div id="print-log-container" class="debug-info">
    <LogContainer logs={printLogs} />
  </div>
</div>

<style>
  :global(body, html) {
    padding: 0;
    margin: 0;
  }
  #print-window-wrapper {
    width: 100vw;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  #print-debug-info {
    flex: 0 0 auto;
    background: #f0f0f0;
    padding: 10px;
    border-bottom: 1px solid #ccc;
    font-family: monospace;
    z-index: 1000;
  }

  .debug-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .debug-info-left {
    flex: 1;
  }

  .debug-controls {
    flex-shrink: 0;
    margin-left: 16px;
  }

  .page-container-wrapper {
    flex: 1;
    position: relative;
    height: 0;
    min-height: 0;
    overflow: hidden;
  }

  @media print {
    #print-debug-info,
    #print-log-container {
      display: none;
    }
    .debug-info {
      display: none;
    }
  }

  .retry-info {
    color: #ff9800;
    font-weight: bold;
  }

  .queue-info {
    margin-top: 4px;
  }

  .queue-info span {
    color: #666;
  }

  .queue-info span.active {
    color: #2196f3;
    font-weight: bold;
  }
</style>
</file>

<file path="src/renderer/src/window/debug/main.ts">
import { mount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

export default app;
</file>

<file path="src/renderer/src/window/editor/App.svelte">
<script lang="ts">
  import { settings } from '@/stores/settings.svelte.js';
  import CodeEditor from '@components/codeEditor/CodeEditor.svelte';
  import BlockTxt from '@components/pageElement/BlockTxt.svelte';
  import { IpcEmitter, IpcListener } from '@electron-toolkit/typed-ipc/renderer';
  import type { IpcEvents, IpcRendererEvent } from 'src/types/ipc';
  import { onMount } from 'svelte';

  // Initialize settings store
  settings.init();

  const emitter = new IpcEmitter<IpcEvents>();
  const ipc = new IpcListener<IpcRendererEvent>();

  let editorValue = $state('');
  let editorLanguage = $state<'css' | 'html'>('css');
  let currentFilePath = $state<string | null>(null);
  let isDocumentEdited = $state(false);
  let storageKey = $state<string>('editor:unknown');
  let ignoreNextChange = $state(false);

  // Load content from localStorage on startup
  onMount(() => {
    // If this is a new session, make sure we don't have a document marked as edited
    emitter.invoke('editor:set-document-edited', false);

    // Set default represented filename
    emitter.invoke('editor:set-represented-file', storageKey);

    // Set up keyboard shortcuts
    document.addEventListener('keydown', handleKeyDown);

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  });

  // Handle keyboard shortcuts
  function handleKeyDown(event: KeyboardEvent): void {
    // Check for Cmd+S (Mac) or Ctrl+S (Windows/Linux)
    if ((event.metaKey || event.ctrlKey) && event.key === 's') {
      event.preventDefault();
      saveContent();
    }
  }

  $effect(() => {
    if (!editorValue) {
      console.log('editorValue', editorValue);
      updateStorageKey();
      const savedContent = localStorage.getItem(storageKey);
      if (savedContent) {
        editorValue = savedContent;
      }
    }
  });

  // Handle editor init event
  ipc.on('editor:init', (_, options) => {
    editorValue = options.content;
    editorLanguage = options.language;

    // Update storage key based on language
    updateStorageKey();

    // Try to load from localStorage first
    const savedContent = localStorage.getItem(storageKey);
    if (savedContent) {
      // Don't mark as edited on initial load from localStorage
      ignoreNextChange = true;
      editorValue = savedContent;
    }
  });

  // Handle when a file is opened
  ipc.on('editor:opened-file', (_, filePath) => {
    currentFilePath = filePath;
    updateStorageKey();

    // Save to localStorage
    localStorage.setItem(storageKey, editorValue);

    // Reset the edited state
    isDocumentEdited = false;
    emitter.invoke('editor:set-document-edited', false);
  });

  ipc.on('editor:setLanguage', (_, language) => {
    editorLanguage = language;
    updateStorageKey();
  });

  // Handle save events from menu
  ipc.on('editor:save', () => {
    saveContent();
  });

  ipc.on('editor:save-as', async () => {
    // Force a new save dialog by temporarily clearing the current file path
    const oldFilePath = currentFilePath;
    currentFilePath = null;
    await saveContent();

    // If user canceled the save dialog, restore the old file path
    if (!currentFilePath && oldFilePath) {
      currentFilePath = oldFilePath;
      updateStorageKey();
    }
  });

  // Handle save complete event
  ipc.on('editor:save-complete', (_, filePath) => {
    if (filePath) {
      currentFilePath = filePath;

      // Update storage key to use the file path
      storageKey = `editor:file:${filePath}`;

      // Save to localStorage
      localStorage.setItem(storageKey, editorValue);

      console.log(`File saved to ${filePath}`);
    }
  });

  // Update storage key based on current state
  function updateStorageKey(): void {
    if (currentFilePath) {
      storageKey = `editor:file:${currentFilePath}`;
    } else {
      storageKey = `editor:${editorLanguage}:unknown`;
    }
  }

  // Save content to file and localStorage
  async function saveContent(): Promise<void> {
    if (!currentFilePath) {
      // If no file path, open save dialog
      const filePath = await emitter.invoke('editor:save-dialog');
      if (filePath) {
        currentFilePath = filePath;
        updateStorageKey();

        // Set the represented filename in the window
        await emitter.invoke('editor:set-represented-file', filePath);
      } else {
        // User canceled the dialog
        return;
      }
    }

    // Save content to file
    if (currentFilePath) {
      emitter.send('editor:save-to-file', { content: editorValue, filePath: currentFilePath });

      // Set document as not edited
      isDocumentEdited = false;
      await emitter.invoke('editor:set-document-edited', false);
    }

    // Always save to localStorage
    localStorage.setItem(storageKey, editorValue);
  }

  // Update appropriate setting when editor value changes and send to remote
  function handleEditorChange(value: string): void {
    console.log('handleEditorChange', value);
    editorValue = value;

    // Don't mark as edited if we're ignoring this change (e.g., initial load from localStorage)
    if (ignoreNextChange) {
      ignoreNextChange = false;
    } else {
      isDocumentEdited = true;
      emitter.invoke('editor:set-document-edited', true);
    }

    // Save to localStorage
    localStorage.setItem(storageKey, value);

    // Send the update to remote settings in other windows
    // This will not affect the main settings store in other windows
    if (editorLanguage === 'css') {
      emitter.send('editor:settings-updated', { editorCss: value });
    } else if (editorLanguage === 'html') {
      emitter.send('editor:settings-updated', { svgFilters: value });
    }
  }

  function saveSnapshotOfRemoteSettings(): void {
    emitter.send('editor:command', 'save-snapshot', {
      editorCss: editorValue,
      svgFilters: settings.svgFilters,
    });
  }
</script>

<div class="print-window">
  <div class="header">
    <BlockTxt
      content={`Editor (${editorLanguage})${isDocumentEdited ? ' *' : ''}`}
      settings={{
        editorCss: editorLanguage === 'css' ? editorValue : settings.editorCss,
        controllerSettings: settings.controllerSettings,
        svgFilters: editorLanguage === 'html' ? editorValue : settings.svgFilters,
      }}
    />
  </div>

  <div class="actions">
    <button onclick={() => saveContent()}>Save</button>
    <button onclick={() => saveSnapshotOfRemoteSettings()}>Save Snapshot</button>
  </div>

  <div class="editor-container">
    <CodeEditor
      bind:value={editorValue}
      language={editorLanguage}
      controllerSettings={settings.controllerSettings}
      onChange={handleEditorChange}
      pureStyle={true}
    />
  </div>
</div>

<style>
  :global(body) {
    margin: 0;
  }

  .print-window {
    width: 100%;
    height: 100vh;
    display: flex;
    flex-direction: column;
    background: #fff;
  }
  :global(cm-gutters) {
    app-region: drag;
    user-select: none;
  }

  .header {
    position: absolute;
    top: 1rem;
    right: 1rem;
    z-index: 10;
  }

  .actions {
    position: absolute;
    top: 1rem;
    left: 1rem;
    z-index: 10;
  }

  .actions button {
    padding: 0.5rem;
    background: #eee;
    border: 1px solid #ccc;
    border-radius: 3px;
    cursor: pointer;
    margin-right: 0.5rem;
  }

  .actions button:hover {
    background: #ddd;
  }

  .editor-container {
    flex: 1;
    position: relative;
    height: 100%;
  }
</style>
</file>

<file path="src/renderer/src/window/editor/main.ts">
import { mount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

export default app;
</file>

<file path="src/renderer/src/window/print/App.svelte">
<script lang="ts">
  import { IpcEmitter, IpcListener } from '@electron-toolkit/typed-ipc/renderer';
  import { onMount, tick } from 'svelte';
  import { printJobSchema, type PrintJob, type PrintRequest } from '../../../../types/index.js';
  import type { IpcEvents, IpcRendererEvent } from '../../../../types/ipc.js';

  const ipc = new IpcListener<IpcRendererEvent>();
  const emitter = new IpcEmitter<IpcEvents>();

  // eslint-disable-next-line no-undef
  let children = $state<NodeListOf<HTMLSpanElement> | null>(null);

  let currentPrintId = $state<string | null>(null);

  // Refs for DOM elements
  let printContainer: HTMLElement;

  // Content state
  let printContent = $state('');
  let svgFiltersContent = $state('');
  // Reference to the dynamically injected style element
  let styleElement: HTMLStyleElement | null = $state(null);

  class Status {
    #logs: { msg: string; error: boolean | Error; warning: boolean }[] = $state([
      {
        msg: 'Waiting for print job...',
        error: false,
        warning: false,
      },
    ]);

    #pushLog({
      msg,
      error = false,
      warning = false,
    }: {
      msg: string;
      error?: boolean | Error;
      warning?: boolean;
    }) {
      const entry = { msg, error, warning };
      this.#logs.push(entry);
    }

    #sideEffect(entry) {
      const time = new Date().toTimeString().split(' ')[0];
      const printIdTitle = currentPrintId ? `${currentPrintId} - ` : '';
      const message = `[${time}] ${printIdTitle}${entry.msg}`;
      document.title = message;
      if (entry.error) console.error(message);
      if (entry.warning) console.warn(message);
      console.log(message);
    }

    set msg(value: string) {
      this.#pushLog({ msg: value });
      this.#sideEffect(this.state);
    }

    set warn(value: string) {
      this.#pushLog({ msg: value, warning: true });
      this.#sideEffect(this.state);
    }

    set err(err: Error | string | unknown) {
      // TODO: send error back to main process
      const errorMsg = err instanceof Error ? err.message : String(err);
      this.#pushLog({ msg: `${errorMsg}`, error: err instanceof Error ? err : true });
      this.#sideEffect(this.state);
    }

    get err(): Error {
      if (this.state.error instanceof Error) return this.state.error;
      return new Error(this.state.msg);
    }

    get state() {
      return this.#logs[this.#logs.length - 1];
    }
  }

  const status = new Status();

  async function executePrint(printRequest: PrintRequest) {
    currentPrintId = printRequest.printId;
    status.msg = 'ReadyToBePrinted:' + currentPrintId;

    try {
      await emitter.invoke('PrintWindow:ReadyToBePrinted', printRequest);
    } catch (error) {
      status.err = error;
    }
  }

  onMount(() => {
    status.msg = 'Print window initialized';

    // Handle print job setup
    ipc.on('PrintWindow:printJob', async (_event, printJobUnsave: PrintJob) => {
      try {
        const printJob = printJobSchema.parse(printJobUnsave);

        status.msg = `Processing: ${printJob.printId} (Attempt ${printJob.attempt}/${printJob.maxRetries})`;

        // Clear the container
        printContent = '';

        // Update styles
        if (printJob.pageContent.editorCss) {
          // Remove previous style element if it exists
          if (styleElement) {
            document.head.removeChild(styleElement);
          }

          // Create and inject new style element
          styleElement = document.createElement('style');
          styleElement.textContent = printJob.pageContent.editorCss;
          document.head.appendChild(styleElement);

          status.msg = `Styles loaded (${printJob.pageContent.editorCss.length} bytes)`;
        } else {
          status.warn = 'No inline styles provided for print job';
        }

        // Inject SVG filters if they exist
        if (printJob.pageContent.svgFilters) {
          status.msg = 'Adding SVG filters';
          svgFiltersContent = printJob.pageContent.svgFilters;
        } else {
          status.warn = 'No SVG filters provided for print job';
          svgFiltersContent = '';
        }

        // Set the content
        printContent = printJob.pageContent.html;

        // Wait for Svelte to update the DOM
        await tick();

        // Get child spans for debugging
        if (printContainer) {
          children = printContainer.querySelectorAll('span');

          if (children.length === 0) {
            status.warn = 'Print content contains no text spans';
          }
        }

        status.msg = 'Content loaded, waiting 5 seconds before print...';

        await new Promise((resolve) => setTimeout(resolve, 5000));

        status.msg = 'Printing...';

        console.log('Executing print with settings:', printJob);

        // Execute print with the same settings including printId
        await executePrint(printJob);
      } catch (error) {
        status.err = error;
      }
    });
  });
</script>

<div id="print-window-wrapper">
  <!-- SVG filters container-->
  {#if svgFiltersContent}
    <div id="svg-filters" style="display: none">
      <!-- eslint-disable-next-line svelte/no-at-html-tags -->
      {@html svgFiltersContent}
    </div>
  {/if}

  <div class="page-context">
    <page size="A3">
      <div bind:this={printContainer} id="print-container">
        <!-- eslint-disable-next-line svelte/no-at-html-tags-->
        {@html printContent}
      </div>
    </page>
  </div>
</div>

<style>
  :global(body, html) {
    padding: 0;
    margin: 0;
    overflow: scroll;
  }

  .page-context {
    margin: 1cm;
  }

  page[size='A3'] {
    font-size: 2em;
    font-weight: 100;
    text-align: left;
    display: block;
    width: calc(297.3mm * 0.86);
    height: calc(420.2mm * 0.895);
    padding: 2cm;
    background: url('../../assets/scan.png');
    background-size: 100% 100%;
    outline: 1px solid red;
  }

  @media print {
    :global(body, html) {
      print-color-adjust: exact;
      -webkit-print-color-adjust: exact;
    }
    page[size='A3'] {
      background: white;
      outline: none;
    }
    .page-context {
      margin: 0;
    }
  }
</style>
</file>

<file path="src/renderer/src/window/print/main.ts">
import { mount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

export default app;
</file>

<file path="src/renderer/src/App.svelte">
<script lang="ts">
  import PrintStatusBar from '@/components/status/PrintStatusBar.svelte';
  import { remoteSettings } from '@/stores/remoteSettings.svelte.ts';
  import { settings } from '@/stores/settings.svelte.js';
  import { snapshots } from '@/stores/snapshots.svelte.js';
  import CodeEditor from '@components/codeEditor/CodeEditor.svelte';
  import ControllerManager from '@components/midi/ControllerManager.svelte';
  import BlockTxt from '@components/pageElement/BlockTxt.svelte';
  import TransInfoMessagesLog from '@components/status/TransInfoMessagesLog.svelte';
  import SnapshotManager from '@components/ui/SnapshotManager.svelte';
  import log from 'electron-log/renderer';
  import type { BlockTxtSettings, FontFamily, TxtObject } from '../src/types';

  import type { PrintRequest, PrintTask } from 'src/types';

  import type { SvelteComponent } from 'svelte';
  import { tick } from 'svelte';
  import { WebMidi } from 'webmidi';

  import { IpcEmitter, IpcListener } from '@electron-toolkit/typed-ipc/renderer';
  import type { IpcEvents, IpcRendererEvent } from 'src/types/ipc';

  const ipc = new IpcListener<IpcRendererEvent>();
  const emitter = new IpcEmitter<IpcEvents>();

  let {
    omittedSilenceFragments = [
      '[ Silence ]',
      '[silence]',
      '[BLANK_AUDIO]',
      '[ [ [ [',
      '[ [ [',
      '[ [',
      '[',
      '(buzzer)',
      '(buzzing)',
      '.',
    ],
  } = $props();

  // Only Contains the final sentences
  let committedContent = $state<TxtObject[]>([]);

  // Contains all incoming TTS sentences
  let allIncomingTTSMessages = $state<string[]>([]);

  let currentSentence = $state<TxtObject>({} as TxtObject);

  let fontFamilys = $state<FontFamily[]>([
    { name: 'Garamondt-Regular' },
    { name: 'American Typewriter' },
    { name: 'Arial' },
    { name: 'Arial Black' },
    { name: 'Arial Narrow' },
    { name: 'SpaceMono' },
    { name: 'Unifont' },
    { name: 'OracleGM-RegularMono' },
    { name: 'Neureal-Regular' },
    { name: 'NIKITA-Regular' },
    { name: 'Yorkshire' },
  ]);

  let printerSettings = $state<PrintTask>({
    deviceName: 'Xerox_Phaser_5550N',
    yes: false,
    silent: undefined,
  });

  // Page counter
  let pageNumber = $state(1);

  let isSuccessfulPrint = $state(true);
  let printStatusBar = $state<PrintStatusBar | undefined>(undefined);

  // State for sentences waiting to be committed while printing
  let isPrinting = $state(false);
  let isHandlingOverflow = $state(false); // Flag to prevent recursive overflow handling

  let mode = $state<'full' | 'mini'>('full');

  // Initialize settings when the app starts
  $effect(() => {
    if (!settings.controllerSettings.length) settings.init();
  });

  // Ensure snapshots are loaded when the app starts
  $effect(() => {
    if (settings.controllerSettings.length > 0) {
      snapshots.loadSnapshots().catch(console.error);
    }
  });

  let currentContentList = $derived([...committedContent, currentSentence]);

  ipc.on('whisper-ccp-stream:transcription', (_, value: string) => {
    allIncomingTTSMessages = [value, ...allIncomingTTSMessages];
    const formattedSentence = formatTTSasTxtObject(value);

    if (isHandlingOverflow) {
      console.warn('Overflow handling in progress, discarding:', value);
      return;
    }

    if (String(value).endsWith('NEW')) {
      // Final sentence received
      currentSentence = {} as TxtObject; // Clear current visualization

      // Only commit if it's not in the unwanted list
      if (
        !omittedSilenceFragments.some(
          (x) => x.toLowerCase() === formattedSentence.content.toLowerCase().trim(),
        )
      ) {
        log.silly('Commiting:', formattedSentence.content);
        committedContent = [...committedContent, formattedSentence];
      }
    } else {
      // Always show partial results, even if they would be filtered when final
      currentSentence = formattedSentence;
    }
  });

  function formatTTSasTxtObject(tts: string): TxtObject {
    const removeNEWKeyword = String(tts).replace('NEW', '').trim();
    const txtSettings: BlockTxtSettings = {
      editorCss: remoteSettings.editorCss,
      controllerSettings: settings.controllerSettings,
      svgFilters: remoteSettings.svgFilters,
    };
    return {
      type: BlockTxt as unknown as typeof SvelteComponent,
      content: removeNEWKeyword,
      settings: JSON.parse(JSON.stringify(txtSettings)), // Deep copy of current settings
      id: Math.random(),
    };
  }

  // Watch for code changes and mark as unsaved
  $effect(() => {
    if (settings.editorCss || settings.svgFilters) {
      settings.markUnsaved();
    }
  });

  // Update the style tag in the header when editorCss changes from remote
  $effect(() => {
    if (typeof document !== 'undefined') {
      // Get the existing style tag or create a new one if needed
      let styleTag = document.head.querySelector('style[data-inline-style]');
      if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.setAttribute('data-inline-style', 'true');
        document.head.appendChild(styleTag);
      }

      // Update the content of the style tag with remote settings
      styleTag.textContent = remoteSettings.editorCss || '';
    }
  });

  async function handleOverflow(overflowingItem: TxtObject): Promise<void> {
    // Don't handle overflow if we're already handling overflow
    if (isHandlingOverflow) return;

    try {
      isHandlingOverflow = true;
      console.log('Handling overflow for:', overflowingItem.content);

      // Find the index of the overflowing item
      const index = committedContent.findIndex((item) => item.id === overflowingItem.id);
      if (index === -1) return;

      // If this is the first item on the page and it's overflowing,
      // we need to handle it specially to avoid an infinite loop
      if (index === 0) {
        console.warn(
          'First item on page is overflowing - forcing it to print alone:',
          overflowingItem.content,
        );
        // Print just this item on its own page
        const itemToPrint = [overflowingItem];
        const remainingItems = committedContent.slice(1);

        // Update committed content to only include the overflowing item
        committedContent = itemToPrint;
        await tick(); // Wait for DOM update

        // Print current page and continue with remaining items
        await printFile();
        // Clear the printed content before setting the remaining items
        committedContent = [];
        await tick(); // Wait for DOM update
        committedContent = remainingItems;
        return;
      }

      // Normal case - split at the overflowing item
      const itemsToPrint = committedContent.slice(0, index);
      const itemsForNextPage = committedContent.slice(index);

      // Print current page and continue with remaining items
      committedContent = itemsToPrint;
      await tick(); // Wait for DOM update
      await printFile();
      // Clear the printed content before setting the remaining items
      committedContent = [];
      await tick(); // Wait for DOM update
      committedContent = itemsForNextPage;
    } finally {
      isHandlingOverflow = false;
    }
  }

  async function printFile(): Promise<void> {
    if (!printStatusBar) {
      console.error('❌ No print status bar found');
      isSuccessfulPrint = false;
      return;
    }
    console.log('🖨️ Starting print process');
    await tick(); // Wait for DOM update

    try {
      const pageElement = document.querySelector('page');
      if (!pageElement) {
        console.error('❌ No page element found');
        isSuccessfulPrint = false;
        return;
      }

      // Remove current elements before printing more efficiently
      pageElement.querySelectorAll('.current').forEach((element) => element.remove());

      const pageContent = pageElement.innerHTML;
      if (!pageContent) {
        console.error('❌ Invalid page content');
        isSuccessfulPrint = false;
        return;
      }

      // Create a print request in the status bar
      const printId = printStatusBar.addPrintRequest()?.toString();
      if (!printId) {
        console.error('❌ Failed to create print ID');
        isSuccessfulPrint = false;
        return;
      }

      // Create request with minimal references
      const printRequest: PrintRequest = {
        printId,
        pageNumber: pageNumber,
        do: {
          print: {
            deviceName: printerSettings.deviceName,
            yes: printerSettings.yes,
            silent: printerSettings.silent,
          },
          pdfSave: {
            yes: true,
          },
        },
        pageContent: {
          editorCss: remoteSettings.editorCss,
          svgFilters: remoteSettings.svgFilters,
          html: pageContent,
        },
      };

      // Send request and clear references
      emitter.send('print', printRequest);
      committedContent = [];

      // Increment page number after successful print
      pageNumber++;
    } catch (error) {
      console.error('❌ Error during print:', error);
      isSuccessfulPrint = false;
    }
  }

  // Initialize WebMidi
  WebMidi.enable().catch((err) => console.error('WebMidi could not be enabled:', err));

  // Listen for WebMidi events
  WebMidi.addListener('connected', (e) => {
    console.log('WebMidi device connected:', e);
    settings.setupControllers(WebMidi);
  });

  WebMidi.addListener('disconnected', (e) => {
    console.log('WebMidi device disconnected:', e);
  });

  // Handle editor commands
  ipc.on('editor:command', async (_, command, payload) => {
    console.log('Received editor command:', command, payload);

    if (command === 'save-snapshot') {
      await snapshots.saveSnapshot();
    }
  });

  function clearAll(): void {
    console.log('🗑️ Clearing all content');
    committedContent = [];
  }

  // Function to open editor window for either CSS or SVG filters
  async function openEditor(language: 'css' | 'html'): Promise<void> {
    try {
      const content = language === 'css' ? settings.editorCss : settings.svgFilters;

      // First update our remote settings with the current settings
      if (language === 'css') {
        remoteSettings.update({ editorCss: content }, false);
      } else {
        remoteSettings.update({ svgFilters: content }, false);
      }

      // Then open the editor window with the content
      await emitter.invoke('editor:openFile', {
        content,
        language,
      });

      console.log(`Opened ${language} editor window`);
    } catch (error) {
      console.error(`Failed to open editor: ${error}`);
    }
  }

  // Add IPC listener for mode changes
  ipc.on('window:mode', (_, newMode: 'full' | 'mini') => {
    mode = newMode;
  });
</script>

<!-- svelte:head meta title -->
<svelte:head>
  <title>a-trans(crip)tion-live-coding-VJ-PDF-printing-tool</title>
  <!-- The static style tag below is kept for initial rendering, but will be replaced/updated by the $effect -->
  <style data-inline-style>
{settings.editorCss}
  </style>
</svelte:head>

<div class="text-preview-container">
  <BlockTxt
    content="Text Preview"
    settings={{
      editorCss: remoteSettings.editorCss,
      controllerSettings: settings.controllerSettings,
      svgFilters: remoteSettings.svgFilters,
    }}
  />
</div>

<main>
  {#if currentContentList.length > 0}
    <div class={mode === 'mini' ? 'print-context-mini' : 'print-context'}>
      <page size="A3" id="page">
        <div class="content-context">
          {#each committedContent as item (item.id)}
            <item.type
              content={item.content}
              settings={item.settings}
              onOverflow={() => handleOverflow(item)}
            />
          {/each}
          {#if !isPrinting && currentSentence?.type}
            <currentSentence.type
              content={currentSentence.content}
              settings={{
                editorCss: remoteSettings.editorCss,
                controllerSettings: settings.controllerSettings,
                svgFilters: remoteSettings.svgFilters,
              }}
              isCurrent
            />
          {/if}
          <div
            class="page-number #num"
            style="position: absolute; bottom: 1em; right: 1em;font-size: 2rem;"
          >
            <BlockTxt
              content={`${pageNumber}`}
              settings={{
                editorCss: remoteSettings.editorCss,
                controllerSettings: settings.controllerSettings,
                svgFilters: remoteSettings.svgFilters,
              }}
            />
          </div>
        </div>
      </page>
    </div>
  {/if}

  {#if mode === 'full'}
    <div class="print-non" class:printFailed={!isSuccessfulPrint}>
      <div class="infobox">
        <div class="codeEditorHeader">
          <div class="dot" class:greenDot={settings.codeEditorContentSaved}></div>
          <button onclick={() => openEditor('css')}>Open in Editor Window</button>
        </div>
        <CodeEditor
          bind:value={settings.editorCss}
          language="css"
          controllerSettings={settings.controllerSettings}
          {fontFamilys}
        />

        <hr />

        <ControllerManager bind:controllerSettings={settings.controllerSettings}
        ></ControllerManager>

        <hr />

        <div class="printControls">
          <button onclick={printFile}>PRINT</button>
          <input id="pageNumberInput" bind:value={pageNumber} type="number" />
          <button onclick={clearAll}>CLEAR ALL</button>
          <button onclick={() => emitter.invoke('open-pdf-folder')}> OPEN PDFs FOLDER </button>
          <input bind:value={printerSettings.deviceName} type="text" disabled />
          <label><input bind:checked={printerSettings.yes} type="checkbox" />Force Print</label>
        </div>

        <hr />

        <SnapshotManager />

        <hr />

        <div class="codeEditorHeader">
          <h3>SVG Filters</h3>
          <button onclick={() => openEditor('html')}> ❇️ </button>
        </div>
        <CodeEditor
          bind:value={settings.svgFilters}
          language="html"
          controllerSettings={settings.controllerSettings}
        />
        <div style="display: none">
          <!-- eslint-disable-next-line svelte/no-at-html-tags -->
          {@html settings.svgFilters}
        </div>
        <TransInfoMessagesLog />
      </div>
    </div>
  {/if}

  <PrintStatusBar bind:this={printStatusBar} />
</main>

<svelte:window />

<style>
  :global(html, body) {
    margin: 0;
    padding: 0;
  }

  .text-preview-container {
    position: fixed;
    top: 10px;
    left: 10px;
    z-index: 1000;
    font-size: 2rem;
    pointer-events: none;
    /* background: white; */
  }

  main {
    text-align: left;
    font-family: 'Garamondt-Regular', 'American Typewriter', monospace;
    display: grid;
    grid-template-columns: 1fr;
    height: 100%;
    padding: 0.5rem;
  }
  page {
    background: white;
    display: block;
    box-shadow: 0 0 0.5cm rgba(0, 0, 0, 0.5);
  }
  .print-context-mini {
    --page-left: 50%;
  }

  page {
    width: calc(297.3mm * 0.86);
    height: calc(420.2mm * 0.895);
    padding: 2cm;
    background: url('../src/assets/scan.png');
    background-size: 100% 100%;
    outline: 1px solid red;
    position: fixed;
    top: 50%;
    left: var(--page-left, 70%);
    transform: translate(-50%, -50%) scale(var(--page-scale, 0.5)) translate3d(0, 0, 0);
    z-index: 500;
    contain: strict;
  }

  page:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: url('../src/assets/scan.png');
    mix-blend-mode: multiply;
  }
  .print-context {
    text-align: left;
    font-size: 2em;
    font-weight: 100;
    z-index: 500;
    position: fixed;
  }

  :global(h1) {
    color: #ff3e00;
    text-transform: uppercase;
    font-size: 4em;
    font-weight: 100;
  }
  .infobox {
    font-family: 'SpaceMono', serif;
    max-width: 40vw;
    border: 1px solid black;
    margin: 1rem;
    padding: 1rem;
  }
  .content-context {
    height: 100%;
  }
  .content-context:hover {
    outline: 2px solid #00ff00;
  }

  .printControls {
    display: flex;
    align-items: baseline;
    gap: 0.5rem;
    flex-wrap: wrap;
  }
  .printFailed {
    background: red;
  }

  .dot {
    background: red;
    width: 0.5em;
    height: 0.5em;
    border-radius: 50%;
  }
  .greenDot {
    background: green;
  }

  #pageNumberInput {
    width: 5em;
    text-align: center;
  }

  .codeEditorHeader {
    display: flex;
    justify-content: space-between;
    align-items: right;
    margin-bottom: 0.5rem;
  }

  .codeEditorHeader h3 {
    margin: 0;
  }

  @media print {
    * {
      print-color-adjust: exact;
      -webkit-print-color-adjust: exact;
    }
    .print-non {
      display: none;
    }
    .print-context {
      width: 100%;
    }
    page[size='A3'] {
      transform: none;
      top: 0;
      left: 0;
    }
    :global(body, page, main) {
      background: white;
      margin: 0;
      padding: 0;
      box-shadow: none;
      display: block;
    }
    :global(span.current) {
      display: none !important;
    }
  }
</style>
</file>

<file path="src/renderer/src/env.d.ts">
/// <reference types="svelte" />
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly RENDERER_VITE_OPENROUTER_API_KEY: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
</file>

<file path="src/renderer/src/main.ts">
import { mount } from 'svelte';
import App from './App.svelte';

import './assets/global.css';

const app = mount(App, {
  target: document.body,
});

export default app;
</file>

<file path="src/renderer/src/types.ts">
import type { SvelteComponent } from 'svelte';

export interface FontFamily {
  name: string;
}

export interface BlockTxtSettings {
  editorCss: string;
  controllerSettings: ControllerSetting[];
  svgFilters?: string;
}

export interface ControllerSetting {
  name: string;
  var: string;
  value: number;
  default: number;
  step: number;
  knobNR: number;
  range: [number, number];
  keys?: string[];
}

export interface Settings {
  controllerSettings: ControllerSetting[];
  editorCss: string;
  svgFilters: string;
}

export interface TxtObject {
  type: typeof SvelteComponent;
  content: string;
  settings: BlockTxtSettings;
  id: number;
}
</file>

<file path="src/renderer/debug.html">
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <title>Debug Window</title>

    <script type="module" defer src="src/window/debug/main.ts"></script>
  </head>

  <body></body>
</html>
</file>

<file path="src/renderer/editor.html">
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <title>Editor</title>

    <script type="module" defer src="src/window/editor/main.ts"></script>
  </head>

  <body></body>
</html>
</file>

<file path="src/renderer/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <title>Svelte app</title>

    <script type="module" defer src="/src/main.ts"></script>
  </head>

  <body></body>
</html>
</file>

<file path="src/renderer/print.html">
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <title>Print Window</title>

    <!-- <link rel="icon" type="image/png" href="favicon.png" />
    <link rel="stylesheet" href="global.css" />
    <link rel="stylesheet" href="build/print/print.css" /> -->

    <script type="module" defer src="src/window/print/main.ts"></script>
  </head>

  <body></body>
</html>
</file>

<file path="src/types/globals.d.ts">
import { ChildProcess } from 'child_process';

declare global {
  // We're forced to use var in declaration files for globals
  // eslint-disable-next-line no-var
  var streamProcess: ChildProcess | null;
}

export {};
</file>

<file path="src/types/index.ts">
import { z } from 'zod';

/**
 * Print action types
 */
export const printActionSchema = z.enum([
  'PRINT_START',
  'PRINT_COMPLETE',
  'PDF_SAVE',
  'PRINT_ERROR',
]);
export type PrintAction = z.infer<typeof printActionSchema>;

/**
 * Print status types
 */
export const printStatusSchema = z.enum(['SUCCESS', 'ERROR', 'INFO']);
export type PrintStatus = z.infer<typeof printStatusSchema>;

export const printTaskSchema = z.object({
  yes: z.boolean(),
  deviceName: z.string(),
  silent: z.boolean().optional(),
});
export type PrintTask = z.infer<typeof printTaskSchema>;

export const printTasksSchema = z.object({
  print: printTaskSchema,
  pdfSave: z
    .object({
      yes: z.boolean().optional(),
    })
    .optional(),
  pngSave: z
    .object({
      yes: z.boolean().optional(),
    })
    .optional(),
});
export type PrintTasks = z.infer<typeof printTasksSchema>;

/**
 * Base print settings schema
 */
export const printRequestSchema = z.object({
  printId: z.string(),
  pageNumber: z.number(),
  do: printTasksSchema,
  pageContent: z.object({
    editorCss: z.string(),
    svgFilters: z.string(),
    html: z.string(),
  }),
});
export type PrintRequest = z.infer<typeof printRequestSchema>;

/**
 * Print status message schema
 */
export const printStatusMessageSchema = z.object({
  id: z.string(),
  timestamp: z.number(),
  action: printActionSchema,
  status: printStatusSchema,
  message: z.string().optional(),
  error: z.string().optional(),
  path: z.string().optional(),
  details: z.record(z.unknown()).optional(),
});
export type PrintStatusMessage = z.infer<typeof printStatusMessageSchema>;

/**
 * Print job schema
 */
export const printJobSchema = printRequestSchema.extend({
  attempt: z.number().default(1),
  maxRetries: z.number().default(1),
});
export type PrintJob = z.infer<typeof printJobSchema>;

/**
 * Queue status update schema
 */
export const queueStatusSchema = z.object({
  queueLength: z.number(),
  isProcessing: z.boolean(),
});
export type QueueStatus = z.infer<typeof queueStatusSchema>;

/**
 * Print job completion event schema
 */
export const printCompletionEventSchema = z.object({
  printId: z.string(),
  success: z.boolean(),
  error: z.string().optional(),
});
export type PrintCompletionEvent = z.infer<typeof printCompletionEventSchema>;

/**
 * Settings snapshot schema
 */
export const settingsSnapshotSchema = z.object({
  id: z.string(),
  name: z.string(),
  timestamp: z.number(),
  editorCss: z.string(),
  svgFilters: z.string(),
  controllerValues: z.record(z.number()),
});
export type SettingsSnapshot = z.infer<typeof settingsSnapshotSchema>;

/**
 * Settings snapshot list response schema
 */
export const settingsSnapshotListResponseSchema = z.object({
  snapshots: z.array(settingsSnapshotSchema),
  success: z.boolean(),
  error: z.string().optional(),
});
export type SettingsSnapshotListResponse = z.infer<typeof settingsSnapshotListResponseSchema>;
</file>

<file path="src/types/ipc.d.ts">
import type {
  PrintJob,
  PrintRequest,
  PrintStatusMessage,
  QueueStatus,
  SettingsSnapshot,
  SettingsSnapshotListResponse,
} from './index';

// Command types for general IPC communication
export type CommandResponse<T = unknown> = {
  success: boolean;
  data?: T;
  error?: string;
};

// Main process ipc events (from renderer to main)
export type IpcEvents =
  | {
      // listener event map
      print: [request: PrintRequest];
      'print-status': [status: { printId: string; success: boolean; error?: string }];
      'editor:settings-updated': [settings: { editorCss?: string; svgFilters?: string }];
      'editor:stackmode': [mode: { content?: string; clear?: boolean }];
      'editor:save-content': [content: string];
      'editor:save-to-file': [{ content: string; filePath?: string }];
      'editor:command': [command: string, payload?: unknown];
      'window:mode': [mode: 'full' | 'mini'];
      // Command channel events
      'command:execute': [command: string, payload?: unknown];
    }
  | {
      // handler event map
      getStoreValue: (key: string) => unknown;
      setStoreValue: (key: string, value: unknown) => void;
      'open-pdf-folder': () => Promise<boolean>;
      'PrintWindow:ReadyToBePrinted': (request: PrintRequest) => Promise<boolean>;
      // Settings snapshot handlers
      'save-settings-snapshot': (snapshot: SettingsSnapshot) => Promise<SettingsSnapshot>;
      'get-settings-snapshots': () => Promise<SettingsSnapshotListResponse>;
      'load-settings-snapshot': (id: string) => Promise<SettingsSnapshot | null>;
      'delete-settings-snapshot': (id: string) => Promise<boolean>;
      'editor:openFile': (options: {
        content: string;
        language: 'css' | 'html';
      }) => Promise<number>;
      'editor:save-dialog': () => Promise<string | null>;
      'editor:set-represented-file': (filePath: string) => void;
      'editor:set-document-edited': (edited: boolean) => void;
      // Command channel handlers
      'command:execute': <T>(command: string, payload?: unknown) => Promise<CommandResponse<T>>;
    };

// Renderer ipc events (from main to renderer)
export type IpcRendererEvent = {
  // Print related events
  'print-status': [status: PrintStatusMessage];
  'print-queued': [response: { success: boolean; printId: string; error?: string }];
  'queue-status': [status: QueueStatus];
  'PrintWindow:printJob': [job: PrintJob];

  // Transcription related events
  'whisper-ccp-stream:transcription': [data: string];
  'whisper-ccp-stream:status': [status: string];

  // Editor related events
  'editor:init': [options: { content: string; language: 'css' | 'html' }];
  'editor:setLanguage': [language: 'css' | 'html'];
  'settings-sync': [
    settings: { editorCss?: string; svgFilters?: string; createSnapshot?: boolean },
  ];
  'editor:save-complete': [filePath: string | null];
  'editor:save': [];
  'editor:save-as': [];
  'editor:opened-file': [filePath: string];
  'editor:command': [command: string, payload?: unknown];
  'editor:stackmode': [mode: { content?: string; clear?: boolean }];

  // Command channel events
  'command:response': [response: CommandResponse];
  'command:error': [error: string];

  // Window mode events
  'window:mode': [mode: 'full' | 'mini'];
};
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*


# Dependency directories
node_modules/

# Svelte Distribution
public/build/

# Electron Distribution
dist

# Project Build Automation Directory
private

# Desktop Services Store on macOS
.DS_Store

# ignore intermediate wav files
*.wav


out
.eslintcache

# Environment variables
.env
.env.local
</file>

<file path=".prettierignore">
out
dist
pnpm-lock.yaml
LICENSE.md
tsconfig.json
tsconfig.*.json

recordings
resources
doc
</file>

<file path=".prettierrc.yaml">
singleQuote: true
semi: true
trailingComma: all
printWidth: 100
plugins:
  - prettier-plugin-svelte
overrides:
  - files: '*.svelte'
    options:
      parser: svelte
</file>

<file path="electron-builder.yml">
appId: place.milan.pubtranscriptions
productName: Pub-Transcriptions
directories:
  buildResources: build
icon: resources/favicon.png
files:
  - '!**/.vscode/*'
  - '!src/*'
  - '!electron.vite.config.{js,ts,mjs,cjs}'
  - '!{.eslintignore,.eslintrc.cjs,.prettierignore,.prettierrc.yaml,dev-app-update.yml,CHANGELOG.md,README.md}'
  - '!{.env,.env.*,.npmrc,pnpm-lock.yaml}'
  - '!{tsconfig.json,tsconfig.node.json,tsconfig.web.json}'
  - '!recordings/*'
  - '!doc/*'
asarUnpack:
  - resources/**/*
win:
  executableName: Pub-Transcriptions
nsis:
  artifactName: ${name}-${version}-setup.${ext}
  shortcutName: ${productName}
  uninstallDisplayName: ${productName}
  createDesktopShortcut: always
mac:
  entitlementsInherit: build/entitlements.mac.plist
  extendInfo:
    - NSCameraUsageDescription: Application requests access to the device's camera.
    - NSMicrophoneUsageDescription: Application requests access to the device's microphone.
    - NSDocumentsFolderUsageDescription: Application requests access to the user's Documents folder.
    - NSDownloadsFolderUsageDescription: Application requests access to the user's Downloads folder.
  notarize: false
  # asar: false
dmg:
  artifactName: ${name}-${version}.${ext}
linux:
  target:
    - AppImage
    - snap
    - deb
  maintainer: electronjs.org
  category: Utility
appImage:
  artifactName: ${name}-${version}.${ext}
npmRebuild: false
publish:
  provider: generic
  url: https://example.com/auto-updates
</file>

<file path="electron.vite.config.ts">
import { svelte } from '@sveltejs/vite-plugin-svelte';
import { defineConfig, externalizeDepsPlugin } from 'electron-vite';
import { resolve } from 'path';

export default defineConfig({
  main: {
    plugins: [externalizeDepsPlugin()],
  },
  preload: {
    plugins: [externalizeDepsPlugin()],
    build: {
      rollupOptions: {
        input: {
          index: resolve(__dirname, 'src/preload/index.ts'),
        },
      },
    },
  },
  renderer: {
    plugins: [svelte()],
    build: {
      rollupOptions: {
        input: {
          index: resolve(__dirname, 'src/renderer/index.html'),
          print: resolve(__dirname, 'src/renderer/print.html'),
          debug: resolve(__dirname, 'src/renderer/debug.html'),
          editor: resolve(__dirname, 'src/renderer/editor.html'),
        },
      },
    },
    resolve: {
      alias: {
        '@': resolve('src/renderer/src'),
        '@components': resolve('src/renderer/src/components'),
        '@stores': resolve('src/renderer/src/stores'),
        '@utils': resolve('src/renderer/src/utils'),
        '@preload': resolve('src/preload'),
        '@electron': resolve('src/main'),
        '@types': resolve('src/types'),
      },
    },
  },
});
</file>

<file path="eslint.config.mjs">
import eslintConfigPrettier from '@electron-toolkit/eslint-config-prettier';
import tseslint from '@electron-toolkit/eslint-config-ts';
import eslintPluginSvelte from 'eslint-plugin-svelte';

export default tseslint.config(
  { ignores: ['**/node_modules', '**/dist', '**/out'] },
  tseslint.configs.recommended,
  eslintPluginSvelte.configs['flat/recommended'],
  {
    files: ['**/*.svelte'],
    languageOptions: {
      parserOptions: {
        parser: tseslint.parser,
      },
    },
  },
  {
    files: ['**/*.{tsx,svelte}'],
    rules: {
      'svelte/no-unused-svelte-ignore': 'off',
      '@typescript-eslint/explicit-function-return-type': 'off',
    },
  },
  eslintConfigPrettier,
);
</file>

<file path="help-CodemirrorParserTreeStructure.md">
# CSS to Codemirror Parser Tree Documentation

## Overview

This documentation explains how Codemirror parses SCSS code into its internal parser tree representation. Understanding this structure is valuable for developing tools that work with CSS/SCSS syntax, creating custom linters, or building code analysis tools.

## SCSS Source Code Example

The example SCSS code features a single CSS rule set with various properties, including:

- Basic property declarations
- Function calls (e.g., `transform: skew()`)
- Calculations with SASS variables
- Comments (both single-line and multi-line)
- Complex value types (multiple values, comma-separated lists)
- Color values using RGBA functions with variables

```scss
.el {
  display: inline-block;
  transform: skew(30deg, 2deg);
  line-height: $m2 * 2;
  // filter: drop-shadow(16px 16px 10px black);
  letter-spacing: $m5 * 5px;
  text-decoration: blue wavy underline $m1 * 5px;

  // text-shadow: 2px 2px 10px red;
  // text-shadow: 5px 5px #000;
  text-shadow:
    1px 1px 2px red,
    0 0 1em blue,
    0 0 0.2em blue;

  // color: white;
  //text-shadow: 1px 1px 4px black, 0 0 1em black, 0 0 10px black;

  filter: url(#outline);
  font-family: American Typewriter;

  background: rgba($bgR * 2, $bgG, $bgB, $bgA);
  rotate: $r1 * 1deg;
  font-size: $fsz * 1em;
  // font-family: NIKITA-Regular;
}
```

## Parser Tree Structure

Codemirror generates a hierarchical parser tree that breaks down the SCSS code into logical units. The top-level node is `StyleSheet`, which contains the entire document:

```bash
StyleSheet
└── RuleSet
    ├── ClassSelector
    │   └── ClassName (.el)
    └── Block
        ├── Declaration (display)
        ├── Declaration (transform)
        │   └── CallExpression (skew)
        │       └── ArgList
        │           ├── NumberLiteral (30deg)
        │           └── NumberLiteral (2deg)
        ├── Declaration (line-height)
        │   └── BinaryExpression
        │       ├── SassVariableName ($m2)
        │       ├── BinOp (*)
        │       └── NumberLiteral (2)
        ├── LineComment
        ├── Declaration (letter-spacing)
        │   └── BinaryExpression
        │       ├── SassVariableName ($m5)
        │       ├── BinOp (*)
        │       └── NumberLiteral (5px)
        ├── Declaration (text-decoration)
        │   ├── ValueName (blue)
        │   ├── ValueName (wavy)
        │   ├── ValueName (underline)
        │   └── BinaryExpression
        │       ├── SassVariableName ($m1)
        │       ├── BinOp (*)
        │       └── NumberLiteral (5px)
        ├── LineComment
        ├── LineComment
        ├── Declaration (text-shadow)
        │   ├── First shadow group
        │   ├── Second shadow group
        │   └── Third shadow group
        ├── LineComment
        ├── LineComment
        ├── Declaration (filter)
        │   └── CallLiteral (url(#outline))
        ├── Declaration (font-family)
        │   └── ValueName (American Typewriter)
        ├── Declaration (background)
        │   └── CallExpression (rgba)
        │       └── ArgList
        │           ├── BinaryExpression ($bgR * 2)
        │           ├── SassVariableName ($bgG)
        │           ├── SassVariableName ($bgB)
        │           └── SassVariableName ($bgA)
        ├── Declaration (rotate)
        │   └── BinaryExpression
        │       ├── SassVariableName ($r1)
        │       ├── BinOp (*)
        │       └── NumberLiteral (1deg)
        ├── Declaration (font-size)
        │   └── BinaryExpression
        │       ├── SassVariableName ($fsz)
        │       ├── BinOp (*)
        │       └── NumberLiteral (1em)
        └── LineComment
```

## Node Types Explanation

1. **StyleSheet**: Root node that contains all CSS/SCSS content
2. **RuleSet**: A CSS rule containing a selector and declarations block
3. **ClassSelector**: A class-based selector (e.g., `.el`)
4. **Block**: The content within curly braces `{ ... }`
5. **Declaration**: A property-value pair (e.g., `display: inline-block;`)
   - **PropertyName**: The property being set (e.g., `display`)
   - **ValueName**: Simple value identifier (e.g., `inline-block`, `blue`)
6. **NumberLiteral**: Numeric values, often with units
   - **(Unit)**: Indication that the number has a unit (e.g., `px`, `deg`, `em`)
7. **CallExpression**: Function calls (e.g., `skew()`, `rgba()`)
   - **Callee**: Function name
   - **ArgList**: Arguments passed to the function
8. **BinaryExpression**: Mathematical operations (e.g., `$m2 * 2`)
   - **SassVariableName**: SASS variables (e.g., `$m2`)
   - **BinOp**: Binary operator (e.g., `*`)
9. **LineComment**: Single-line comments (`// comment`)
10. **CallLiteral**: URL and other specialized function calls

## Key Observations

1. **Variable Operations**: Sass variables are parsed as SassVariableName nodes, and operations on them are represented as BinaryExpressions.

2. **Comments**: Line comments become LineComment nodes but don't affect the structure of declarations.

3. **Property Values**: Values can be:

   - Simple (ValueName)
   - Complex (multiple ValueName nodes)
   - Function calls (CallExpression)
   - Mathematical expressions (BinaryExpression)

4. **List Values**: For properties that accept multiple comma-separated values (like text-shadow), each group is represented individually in the tree.

5. **Units**: NumberLiteral nodes can have Unit annotations when they include CSS units like px, deg, em.

## Full tree

```
StyleSheet(RuleSet(ClassSelector(ClassName),Block("{"
  ,Declaration(PropertyName,":",ValueName),";"
  ,Declaration(PropertyName,":",CallExpression(Callee,ArgList("(",NumberLiteral(Unit),",",BinaryExpression(SassVariableName,BinOp,NumberLiteral(Unit)),")"))),";"
  ,Declaration(PropertyName,":",BinaryExpression(SassVariableName,BinOp,NumberLiteral)),";"
  ,LineComment
  ,Declaration(PropertyName,":",BinaryExpression(SassVariableName,BinOp,NumberLiteral(Unit))),";"
  ,Declaration(PropertyName,":",ValueName,ValueName,ValueName,BinaryExpression(SassVariableName,BinOp,NumberLiteral(Unit))),";"
  ,LineComment
  ,Declaration(PropertyName,":",NumberLiteral(Unit),NumberLiteral(Unit),ColorLiteral),";"
  ,Declaration(PropertyName,":",NumberLiteral(Unit),NumberLiteral(Unit),NumberLiteral(Unit),ValueName,",",NumberLiteral,NumberLiteral,NumberLiteral(Unit),ValueName,",",NumberLiteral,NumberLiteral,NumberLiteral(Unit),ValueName),";"
  ,LineComment
  ,LineComment
  ,Declaration(PropertyName,":",CallLiteral(CallTag,"(",ParenthesizedContent,")")),";"
  ,Declaration(PropertyName,":",ValueName,ValueName),";"
  ,Declaration(PropertyName,":",CallExpression(Callee,ArgList("(",BinaryExpression(SassVariableName,BinOp,NumberLiteral),",",SassVariableName,",",SassVariableName,",",SassVariableName,")"))),";"
  ,Declaration(PropertyName,":",BinaryExpression(SassVariableName,BinOp,NumberLiteral(Unit))),";"
  ,Declaration(PropertyName,":",BinaryExpression(SassVariableName,BinOp,NumberLiteral(Unit))),";"
  ,LineComment
  ,
"}")))
```
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Milan Gress

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.json">
{
  "name": "pub-transcriptions",
  "version": "3.0.0",
  "description": "Pub Transcriptions",
  "main": "./out/main/index.js",
  "private": false,
  "license": "MIT",
  "author": "Milan Gress <mgress@me.com>",
  "scripts": {
    "format": "prettier --plugin prettier-plugin-svelte --config .prettierrc.yaml --write .",
    "lint": "eslint --cache .",
    "typecheck:node": "tsc --noEmit -p tsconfig.node.json --composite false",
    "svelte-check": "svelte-check --tsconfig ./tsconfig.json",
    "typecheck": "npm run typecheck:node && npm run svelte-check",
    "start": "electron-vite preview",
    "dev": "electron-vite dev",
    "dev:simulate": "electron-vite dev -- --simulate",
    "build": "npm run typecheck && electron-vite build",
    "postinstall": "electron-builder install-app-deps",
    "build:unpack": "npm run build && electron-builder --dir",
    "build:win": "npm run build && electron-builder --win",
    "build:mac": "npm run build && electron-builder --mac",
    "build:linux": "npm run build && electron-builder --linux"
  },
  "dependencies": {
    "@codemirror/autocomplete": "^6.18.6",
    "@codemirror/commands": "^6.8.1",
    "@codemirror/lang-html": "^6.4.9",
    "@codemirror/lang-sass": "^6.0.2",
    "@codemirror/language": "^6.11.0",
    "@codemirror/lint": "^6.8.5",
    "@codemirror/state": "^6.5.2",
    "@codemirror/view": "^6.36.5",
    "@electron-toolkit/preload": "^3.0.1",
    "@electron-toolkit/typed-ipc": "^1.0.2",
    "@electron-toolkit/utils": "^4.0.0",
    "@lezer/common": "^1.2.3",
    "@marimo-team/codemirror-ai": "^0.1.11",
    "@picovoice/pvrecorder-node": "^1.2.8",
    "codemirror": "^6.0.1",
    "electron-log": "^5.3.3",
    "electron-serve": "^1.3.0",
    "electron-store": "^8.2.0",
    "openai": "^4.92.1",
    "uuid": "^11.1.0",
    "wavefile": "^11.0.0",
    "webmidi": "^3.1.12",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "@electron-toolkit/eslint-config-prettier": "^3.0.0",
    "@electron-toolkit/eslint-config-ts": "^3.0.0",
    "@electron-toolkit/tsconfig": "^1.0.1",
    "@sveltejs/vite-plugin-svelte": "^5.0.3",
    "@types/node": "^22.14.0",
    "electron": "^35.1.4",
    "electron-builder": "^25.1.8",
    "electron-vite": "^3.1.0",
    "eslint": "^9.24.0",
    "eslint-plugin-svelte": "^2.46.1",
    "prettier": "^3.5.3",
    "prettier-plugin-svelte": "^3.3.3",
    "svelte": "^5.25.8",
    "svelte-check": "^4.1.5",
    "typescript": "^5.8.3",
    "vite": "^6.2.5"
  }
}
</file>

<file path="pnpm-workspace.yaml">
onlyBuiltDependencies:
  - electron
  - esbuild
</file>

<file path="README.md">
# My book is done when I'mm done speaking

> **A (radio)-live-trans{crip}tion—live-coding-VJ-PDF-printing-tool-?**

Originally to document a [pub Sandberg](https://pub.sandberg.nl) radio show in real-time… to produce a publication during the event itself…
Now a tool to taste the material of spoken language through real-time transcription, typographic intervention (quick-quick you only have 2 seconds to design you type)… _performing design_ is full of mistakes.

![Header graphic Transcribing](doc/Transcribing.webp)

> **The flow:**
>
> 1. streams audio from the microphone
> 2. transcribes the audio using whisper
> 3. places the transcription on a3 page
> 4. every incoming transcription can be individually styled with CSS
> 5. additionally with custom SVG-filters
> 6. custom variables with a midi bridge for live manipulation
> 7. full page gets automatically printed and saved to PDF

## Context

Using machine transcription, and typographic expression as performative act (public and real-time — no way to edit). Embracing all the mistakes of live-performance… neither whisper is able to capture the full bandwidth of reality — neither you and your speed in writing css-parameters on the fly.

![System Overview](doc/printer-laughter.webp)

![the interface](doc/interface-v2.webp)

## Implementation

Built with Electron + Svelte, the system combines:

- Real-time audio transcription (Whisper)
- Dynamic typographic manipulation
- Physical output through continuous printing
- MIDI-based parameter space exploration

![Interface Detail](doc/both_windows_v2.webp)

### Interface

Real-time Manipulation:

- Direct CSS parameter modification
- SVG filter composition
- Typography variation
- Live visual feedback

Physical Output:

- Continuous A3 documentation
- Automated layout composition
- Print queue orchestration
- PDF archival

![Filter Exploration](doc/filter-preview.png)

### MIDI Control

Parameter space exploration through:

- Spatial relationships
- Color systems
- Scale variations
- Visual effects
- Temporal dynamics

### Configuration Example

```javascript
{
  "name": "midi2",
  "var": "m2",
  "value": 1,
  "default": 1,
  "step": 0.1,
  "knobNR": 5,
  "range": [0, 1],
  "keys": {
    "up": "y",
    "down": "Y"
  }
}
```

### Interface Shortcuts

- `ctrl + /` : Comment toggle
- `shift + alt + a` : Block comment
- `Ctrl-Space` : Completion
- `CTRL-Enter` : Line execution
- `CTRL-Shift-Enter` : Full execution
- `ALT-Enter` : Block execution

- `ALT` while draging a val to not clamp to range

Code completion for:

- MIDI variables (`$`)
- SVG filters (`filter: url(#`)
- Typography (`font-family:`)

### Transcription

Custom implementation of Whisper.cpp (Gerganov's version of OpenAI's Whisper) optimized for Apple Metal, providing continuous audio interpretation at 500ms intervals. At the time this version was the most reliable version to support something as messy as a radio program with multiple voices and music playing.

### TODO run in the browser via WASM

The current version relies on a custom implementation of: <https://github.com/milangress/whisper.cpp-milan/blob/master/examples/stream/stream.cpp> that is only compiled for M1 Macs.
This version <https://whisper.ggerganov.com/stream/> could be supported without compiling it as command line tool.

## License

MIT License - See LICENSE for details
</file>

<file path="svelte.config.mjs">
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

export default {
  // Consult https://svelte.dev/docs#compile-time-svelte-preprocess
  // for more information about preprocessors
  preprocess: vitePreprocess(),
};
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [{ "path": "./tsconfig.node.json" }, { "path": "./tsconfig.web.json" }],
}
</file>

<file path="tsconfig.node.json">
{
  "extends": "@electron-toolkit/tsconfig/tsconfig.node.json",
  "include": ["electron.vite.config.*", "src/main/**/*", "src/preload/**/*", "src/types/**/*"],
  "compilerOptions": {
    "types": ["electron-vite/node"],
    "composite": true,
    "allowImportingTsExtensions": true,
    "noEmit": true
  }
}
</file>

<file path="tsconfig.web.json">
{
  "extends": "@electron-toolkit/tsconfig/tsconfig.web.json",
  "include": [
    "src/renderer/src/env.d.ts",
    "src/renderer/src/**/*",
    "src/renderer/src/**/*.svelte",
    "src/preload/*.d.ts",
    "src/types/**/*"
  ],
  "compilerOptions": {
    "composite": true,
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "useDefineForClassFields": true,
    "strict": true,
    "noEmit": true,
    "lib": ["ESNext", "DOM", "DOM.Iterable"],
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/renderer/src/*"],
      "@components/*": ["src/renderer/src/components/*"],
      "@assets/*": ["src/renderer/src/assets/*"],
      "@stores/*": ["src/renderer/src/stores/*"],
      "@utils/*": ["src/renderer/src/utils/*"],
      "@preload/*": ["src/preload/*"],
      "@electron/*": ["src/main/*"],
      "@types/*": ["src/types/*"]
    }
  }
}
</file>

</files>
